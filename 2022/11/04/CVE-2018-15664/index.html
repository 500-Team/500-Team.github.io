<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="CVE-2018-15664 分析复现"/><meta name="keywords" content="CVE复现, click's Blog" /><link rel="alternate" href="/atom.xml" title="click's Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://click.500team.cn/2022/11/04/CVE-2018-15664/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/disqusjs@1.3/dist/disqusjs.css">


    <title>CVE-2018-15664 分析复现 - click's Blog</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">click's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">click's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">CVE-2018-15664 分析复现
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2022-11-04
        </span><span class="post-author">
          / click
        </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90"><span class="toc-text">漏洞分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-cp-%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B"><span class="toc-text">docker cp 实现流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cli-%E7%AB%AF"><span class="toc-text">cli 端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#client-%E7%AB%AF"><span class="toc-text">client 端</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#dockerd-%E7%AB%AF"><span class="toc-text">dockerd 端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%86%E5%BC%B1%E7%82%B9"><span class="toc-text">脆弱点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-gt-%E5%AE%BF%E4%B8%BB%E6%9C%BA"><span class="toc-text">容器 &#x3D;&gt; 宿主机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-gt-%E5%AE%BF%E4%B8%BB%E6%9C%BA-1"><span class="toc-text">容器 &#x3D;&gt; 宿主机</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E8%BF%87%E7%A8%8B"><span class="toc-text">利用过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-gt-%E5%AE%BF%E4%B8%BB%E6%9C%BA-2"><span class="toc-text">容器 &#x3D;&gt; 宿主机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA-gt-%E5%AE%B9%E5%99%A8"><span class="toc-text">宿主机 &#x3D;&gt; 容器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#poc"><span class="toc-text">poc</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E5%A4%8D%E6%96%B9%E6%A1%88"><span class="toc-text">修复方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%9D%E8%80%83"><span class="toc-text">思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">相关知识</span></a></li></ol>
    </div>
  </div><div class="post-content"><h2 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h2><h3 id="docker-cp-实现流程"><a href="#docker-cp-实现流程" class="headerlink" title="docker cp 实现流程"></a>docker cp 实现流程</h3><p><em>docker-ce 项目拆分后，各组件指向其各自的仓库，cli 端项目为 <code>docker/cli</code>，engine 端项目为 <code>moby/moby</code>，这里我用的 commit 节点为 <a target="_blank" rel="noopener" href="https://github.com/docker/docker-ce/tree/e4666ebe817a064c62abf0339d5679868d063148">docker/docker-ce/e4666ebe817a064c62abf0339d5679868d063148</a>，也是修复 CVE-2018-15664 前的最后一次 commit。</em><br><em>在下面的源码分析流程可以大致看出对于一个 docker 命令，应该怎么跟踪它的源码。</em></p>
<h4 id="cli-端"><a href="#cli-端" class="headerlink" title="cli 端"></a>cli 端</h4><p><em>指 docker 命令行</em><br>在 docker client 端，所有 docker 子命令都由 cobra 定义，对应定义的内容如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AddCommands</span><span class="params">(cmd *cobra.Command, dockerCli command.Cli)</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// container 子命令</span></span><br><span class="line">	container.NewContainerCommand(dockerCli),</span><br><span class="line">	container.NewRunCommand(dockerCli),</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewContainerCommand</span><span class="params">(dockerCli command.Cli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	cmd.AddCommand(</span><br><span class="line">		......</span><br><span class="line">		<span class="comment">// 对应 docker container cp 命令</span></span><br><span class="line">		NewCopyCommand(dockerCli),</span><br><span class="line">		......</span><br><span class="line">	)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewCopyCommand</span><span class="params">(dockerCli command.Cli)</span> *<span class="title">cobra</span>.<span class="title">Command</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	cmd := &amp;cobra.Command&#123;</span><br><span class="line">		......</span><br><span class="line">		<span class="comment">// 绑定对应的 handler 函数</span></span><br><span class="line">		RunE: <span class="function"><span class="keyword">func</span><span class="params">(cmd *cobra.Command, args []<span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">			......</span><br><span class="line">			opts.source = args[<span class="number">0</span>]</span><br><span class="line">			opts.destination = args[<span class="number">1</span>]</span><br><span class="line">			<span class="keyword">return</span> runCopy(dockerCli, opts)</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，cli 的 copy 命令由 <code>runCopy()</code> 执行。其定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">runCopy</span><span class="params">(dockerCli command.Cli, opts copyOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	srcContainer, srcPath := splitCpArg(opts.source)</span><br><span class="line">	destContainer, destPath := splitCpArg(opts.destination)</span><br><span class="line"></span><br><span class="line">	copyConfig := cpConfig&#123;</span><br><span class="line">		followLink: opts.followLink,</span><br><span class="line">		copyUIDGID: opts.copyUIDGID,</span><br><span class="line">		quiet:      opts.quiet,</span><br><span class="line">		sourcePath: srcPath,</span><br><span class="line">		destPath:   destPath,</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 确定 cp 方向</span></span><br><span class="line">	<span class="keyword">var</span> direction copyDirection</span><br><span class="line">	<span class="keyword">if</span> srcContainer != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		direction |= fromContainer</span><br><span class="line">		copyConfig.container = srcContainer</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> destContainer != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">		direction |= toContainer</span><br><span class="line">		copyConfig.container = destContainer</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ctx := context.Background()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">switch</span> direction &#123;</span><br><span class="line">	<span class="comment">// 从容器复制到宿主机</span></span><br><span class="line">	<span class="keyword">case</span> fromContainer:</span><br><span class="line">		<span class="keyword">return</span> copyFromContainer(ctx, dockerCli, copyConfig)</span><br><span class="line">	<span class="comment">// 从宿主机复制到容器</span></span><br><span class="line">	<span class="keyword">case</span> toContainer:</span><br><span class="line">		<span class="keyword">return</span> copyToContainer(ctx, dockerCli, copyConfig)</span><br><span class="line">	<span class="keyword">case</span> acrossContainers:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;copying between containers is not supported&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> errors.New(<span class="string">&quot;must specify at least one container source&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当复制方向为从容器拷贝到宿主机时，调用 <code>copyFromContainer()</code>，反之调用 <code>copyToContainer()</code>。<br><code>copyFromContainer()</code> 定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyFromContainer</span><span class="params">(ctx context.Context, dockerCli command.Cli, copyConfig cpConfig)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	dstPath := copyConfig.destPath</span><br><span class="line">	srcPath := copyConfig.sourcePath</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果命令行传入了 -L/--follow-link 参数，则处理 srcPath 的符号链接</span></span><br><span class="line">	<span class="keyword">if</span> copyConfig.followLink &#123;</span><br><span class="line">		srcStat, err := client.ContainerStatPath(ctx, copyConfig.container, srcPath)</span><br><span class="line">		<span class="comment">// 判断是 src 文件是否为符号链接文件，是则解析符号链接内容</span></span><br><span class="line">		<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; srcStat.Mode&amp;os.ModeSymlink != <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// linkTarget 是相对于容器 rootfs 的路径</span></span><br><span class="line">			linkTarget := srcStat.LinkTarget</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// rebaseName 保存的是传入的 srcPath 的 basename，和符号链接所指向的实际文件 basename 可能不同</span></span><br><span class="line">			linkTarget, rebaseName = archive.GetRebaseName(srcPath, linkTarget)</span><br><span class="line">			srcPath = linkTarget</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 从容器中取出所复制内容</span></span><br><span class="line">	content, stat, err := client.CopyFromContainer(ctx, copyConfig.container, srcPath)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 复制源文件信息</span></span><br><span class="line">	srcInfo := archive.CopyInfo&#123;</span><br><span class="line">		Path:       srcPath,  <span class="comment">// 实际复制源文件 path</span></span><br><span class="line">		Exists:     <span class="literal">true</span>,</span><br><span class="line">		IsDir:      stat.Mode.IsDir(),</span><br><span class="line">		RebaseName: rebaseName, </span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preArchive := content</span><br><span class="line">	<span class="comment">// 处理 rebaseName 非空的情况（src 文件为符号链接，且使用了 --follow-link 参数）</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(srcInfo.RebaseName) != <span class="number">0</span> &#123;</span><br><span class="line">		_, srcBase := archive.SplitPathDirEntry(srcInfo.Path)</span><br><span class="line">		preArchive = archive.RebaseArchiveEntries(content, srcBase, srcInfo.RebaseName)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 把容器中取出的内容，复制到 dstPath（dstPath 的符号链接问题会在这里面处理）</span></span><br><span class="line">	<span class="keyword">return</span> archive.CopyTo(preArchive, srcInfo, dstPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>如果使用了 <code>-L/--follow-link</code> 参数，处理容器中源文件是符号链接的情况</li>
<li>调用 <code>client.CopyFromContainer()</code> 获取打包好的 content(tar 包)</li>
<li>调用 <code>archive.CopyTo()</code> 把 content 的内容解包到 dstPath</li>
</ol>
<p>当复制方向为从宿主机到容器时，调用 <code>copyToContainer()</code>，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyToContainer</span><span class="params">(ctx context.Context, dockerCli command.Cli, copyConfig cpConfig)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	dstStat, err := client.ContainerStatPath(ctx, copyConfig.container, dstPath)</span><br><span class="line">	<span class="comment">// 处理容器中的 dst 文件的符号链接（这里不需要设置 -L/--follow-link 参数）</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; dstStat.Mode&amp;os.ModeSymlink != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 如果容器中 dst 文件为符号链接文件，则将 dstInfo.Path 设为所指向的路径</span></span><br><span class="line">		<span class="comment">// CVE-2018-15664：这里的 TOCTOU 问题，在这里检查了容器中文件的 symlink 情况，poc 需要在这里没有解析 symlink</span></span><br><span class="line">		<span class="comment">// 不对，这里判断的是最终的文件是否为符号链接，我们利用的是路径中的目录是符号链接的情况，这里不会影响</span></span><br><span class="line">		linkTarget := dstStat.LinkTarget</span><br><span class="line">		......</span><br><span class="line">		dstInfo.Path = linkTarget</span><br><span class="line">		dstStat, err = client.ContainerStatPath(ctx, copyConfig.container, linkTarget)</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> srcPath == <span class="string">&quot;-&quot;</span> &#123;</span><br><span class="line">		......</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Prepare source copy info.</span></span><br><span class="line">		<span class="comment">// 为 archive 复制准备 CopyInfo 结构体</span></span><br><span class="line">		<span class="comment">// 对于 -L/--follow-link 的处理逻辑在其中（解析 srcPath 的符号链接）</span></span><br><span class="line">		srcInfo, err := archive.CopyInfoSourcePath(srcPath, copyConfig.followLink)</span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将宿主机上的源文件打包成 Tar</span></span><br><span class="line">		srcArchive, err := archive.TarResource(srcInfo)</span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 处理 cp 的几种情况（cp 目录/目录以存在/..），决定最终的复制 dst 路径</span></span><br><span class="line">		<span class="comment">// CVE-2018-15664：poc 这里应该是 dstDir.Exists == true &amp;&amp; dstDir.IsDir == true</span></span><br><span class="line">		dstDir, preparedArchive, err := archive.PrepareArchiveCopy(srcArchive, srcInfo, dstInfo)</span><br><span class="line">		resolvedDstPath = dstDir</span><br><span class="line">		content = preparedArchive</span><br><span class="line">		......</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 调用 client 将打包的数据流传到容器中</span></span><br><span class="line">		<span class="keyword">return</span> client.CopyToContainer(ctx, copyConfig.container, resolvedDstPath, content, options)</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>处理容器中目的文件是符号链接的情况</li>
<li>将宿主机上的源文件打包</li>
<li>调用 <code>client.CopyToContainer()</code> 将打包的数据传到容器中</li>
</ol>
<h4 id="client-端"><a href="#client-端" class="headerlink" title="client 端"></a>client 端</h4><p><em>指向 dockerd 监听端口发送请求的一方</em><br>在 client 端，对应上面两种复制方向，可以看到所调用的两个函数分别为 <code>CopyFromContainer()</code> 和 <code>CopyToContainer()</code>。同时，两种方向都调用了 client 端的 <code>ContainerStatPath()</code> 函数来获取容器中文件的 stat 信息。<br><code>ContainerStatPath()</code> 负责获取容器中文件的 stat 信息，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">ContainerStatPath</span><span class="params">(ctx context.Context, containerID, path <span class="keyword">string</span>)</span> <span class="params">(types.ContainerPathStat, error)</span></span> &#123;</span><br><span class="line">	query := url.Values&#123;&#125;</span><br><span class="line">	query.Set(<span class="string">&quot;path&quot;</span>, filepath.ToSlash(path)) <span class="comment">// Normalize the paths used in the API.</span></span><br><span class="line"></span><br><span class="line">	urlStr := <span class="string">&quot;/containers/&quot;</span> + containerID + <span class="string">&quot;/archive&quot;</span></span><br><span class="line">	<span class="comment">// 构造了一个向 dockerd 监听端口的 /containers/&lt;containerID&gt;/archive?path=&lt;path&gt;</span></span><br><span class="line">	<span class="comment">// 的 HEAD 请求</span></span><br><span class="line">	response, err := cli.head(ctx, urlStr, query, <span class="literal">nil</span>)</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> getContainerPathStatFromHeader(response.header)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CopyFromContainer()</code> 负责获取容器中的源文件内容，并将其以一个 TAR archive Reader 的形式返回，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">CopyFromContainer</span><span class="params">(ctx context.Context, containerID, srcPath <span class="keyword">string</span>)</span> <span class="params">(io.ReadCloser, types.ContainerPathStat, error)</span></span> &#123;</span><br><span class="line">	query := <span class="built_in">make</span>(url.Values, <span class="number">1</span>)</span><br><span class="line">	query.Set(<span class="string">&quot;path&quot;</span>, filepath.ToSlash(srcPath)) <span class="comment">// Normalize the paths used in the API.</span></span><br><span class="line"></span><br><span class="line">	apiPath := <span class="string">&quot;/containers/&quot;</span> + containerID + <span class="string">&quot;/archive&quot;</span></span><br><span class="line">	<span class="comment">// 构造了一个向 dockerd 监听端口的 /containers/&lt;containerID&gt;/archive?path=&lt;srcPath&gt; </span></span><br><span class="line">	<span class="comment">// 的 GET 请求</span></span><br><span class="line">	response, err := cli.get(ctx, apiPath, query, <span class="literal">nil</span>)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取容器中源文件的 stat 信息</span></span><br><span class="line">	stat, err := getContainerPathStatFromHeader(response.header)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> response.body, stat, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>CopyToContainer()</code> 负责将 TAR archive Reader 形式的文件内容复制到容器文件系统中，定义如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(cli *Client)</span> <span class="title">CopyToContainer</span><span class="params">(ctx context.Context, containerID, dstPath <span class="keyword">string</span>, content io.Reader, options types.CopyToContainerOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	query := url.Values&#123;&#125;</span><br><span class="line">	query.Set(<span class="string">&quot;path&quot;</span>, filepath.ToSlash(dstPath)) </span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	apiPath := <span class="string">&quot;/containers/&quot;</span> + containerID + <span class="string">&quot;/archive&quot;</span></span><br><span class="line">	<span class="comment">// 构造了一个向 dockerd 监听端口的 /containers/&lt;containerID&gt;/archive?path=dirname(&lt;dstPath&gt;) </span></span><br><span class="line">	<span class="comment">// 的 put 请求, body 为源文件内容</span></span><br><span class="line">	response, err := cli.putRaw(ctx, apiPath, query, content, <span class="literal">nil</span>)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="dockerd-端"><a href="#dockerd-端" class="headerlink" title="dockerd 端"></a>dockerd 端</h4><p><em>指监听 socket 端口的一方</em><br>在 dockerd 端，对 /containers/* 的请求路由规则在 <code>engine/api/server/router/container/container.go</code> 中的 <code>initRoutes()</code> 中指定。<br>对 <code>containers/&lt;containerID&gt;/archive</code> 的 :</p>
<ul>
<li>HEAD 请求会路由到 <code>headContainersArchive()</code>, 核心调用 <code>s.backend.ContainerStatPath()</code></li>
<li>GET 请求对应 <code>getContainersArchive()</code>, 核心调用<code>s.backend.ContainerArchivePath()</code></li>
<li>PUT 请求对应 <code>putContainersArchive()</code>, 核心调用<code> s.backend.ContainerExtractToDir()</code></li>
</ul>
<p>HEAD 对应的调用链：<code>ContainerStatPath()</code> =&gt; <code>containerStatPath()</code> =&gt; <code>StatPath()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">ContainerStatPath</span><span class="params">(name <span class="keyword">string</span>, path <span class="keyword">string</span>)</span> <span class="params">(stat *types.ContainerPathStat, err error)</span></span> &#123;</span><br><span class="line">	container, err := daemon.GetContainer(name)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	stat, err = daemon.containerStatPath(container, path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> stat, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerStatPath</span><span class="params">(container *container.Container, path <span class="keyword">string</span>)</span> <span class="params">(stat *types.ContainerPathStat, err error)</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 挂载容器的根文件系统</span></span><br><span class="line">	<span class="comment">// 如果是正在运行的容器，那挂载点就是已有的 /var/lib/docker/overlay2/.../merged/</span></span><br><span class="line">	<span class="comment">// 如果容器没有在运行，那就需要暂时将 overlay fs 挂载上来，挂载点和上面的一样，复制完成后再 unmount</span></span><br><span class="line">	<span class="comment">// container.BaseFS = dir ==&gt; (Path() =&gt; /var/lib/docker/overlay2/.../merged/)</span></span><br><span class="line">	<span class="keyword">if</span> err = daemon.Mount(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 挂载容器中的存储卷，也就是在容器中的 mount（不包括伪文件系统，可以通过 docker inspect 查看）</span></span><br><span class="line">	err = daemon.mountVolumes(container)</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// Normalize path before sending to rootfs</span></span><br><span class="line">	path = container.BaseFS.FromSlash(path)</span><br><span class="line">	<span class="comment">// 返回 path(in container) 对应在宿主机上的绝对路径、相对容器文件系统的绝对路径</span></span><br><span class="line">	<span class="comment">// 如果 path 指向容器根文件系统外，则返回 err</span></span><br><span class="line">	resolvedPath, absPath, err := container.ResolvePath(path)</span><br><span class="line">	......</span><br><span class="line">	<span class="keyword">return</span> container.StatPath(resolvedPath, absPath)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the given path should be fully resolved to a path on the host corresponding </span></span><br><span class="line"><span class="comment">// to the given absolute path inside the container.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(container *Container)</span> <span class="title">StatPath</span><span class="params">(resolvedPath, absPath <span class="keyword">string</span>)</span> <span class="params">(stat *types.ContainerPathStat, err error)</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line">	driver := container.BaseFS</span><br><span class="line">	<span class="comment">// resolvedPath 是相对于宿主机文件系统的路径</span></span><br><span class="line">	lstat, err := driver.Lstat(resolvedPath)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 有一次符号链接处理的逻辑，将指向的目标保存到 linkTarget（相对于容器 rootfs 的路径）</span></span><br><span class="line">	<span class="keyword">var</span> linkTarget <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">if</span> lstat.Mode()&amp;os.ModeSymlink != <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// Fully evaluate the symlink in the scope of the container rootfs.</span></span><br><span class="line">		<span class="comment">// 在这里解析符号链接指向的路径（相对于容器文件系统）</span></span><br><span class="line">		hostPath, err := container.GetResourcePath(absPath)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 求相对于容器 rootfs 的相对路径</span></span><br><span class="line">		linkTarget, err = driver.Rel(driver.Path(), hostPath)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make it an absolute path.</span></span><br><span class="line">		linkTarget = driver.Join(<span class="keyword">string</span>(driver.Separator()), linkTarget)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;types.ContainerPathStat&#123;</span><br><span class="line">		Name:       driver.Base(absPath),</span><br><span class="line">		Size:       lstat.Size(),</span><br><span class="line">		Mode:       lstat.Mode(),</span><br><span class="line">		Mtime:      lstat.ModTime(),</span><br><span class="line">		LinkTarget: linkTarget,</span><br><span class="line">	&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>GET 对应的调用链：<code>ContainerArchivePath()</code> =&gt; <code>containerArchivePath()</code> =&gt; <code>archivePath()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">ContainerArchivePath</span><span class="params">(name <span class="keyword">string</span>, path <span class="keyword">string</span>)</span> <span class="params">(content io.ReadCloser, stat *types.ContainerPathStat, err error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 通过 containerId 获取对应容器对象 (*container.Container)</span></span><br><span class="line">	container, err := daemon.GetContainer(name)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打包容器中的源文件</span></span><br><span class="line">	content, stat, err = daemon.containerArchivePath(container, path)</span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> content, stat, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerArchivePath</span><span class="params">(container *container.Container, path <span class="keyword">string</span>)</span> <span class="params">(content io.ReadCloser, stat *types.ContainerPathStat, err error)</span></span> &#123;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 挂载容器根文件系统</span></span><br><span class="line">	<span class="keyword">if</span> err = daemon.Mount(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line">	<span class="comment">// 挂载容器中的存储卷</span></span><br><span class="line">	<span class="keyword">if</span> err = daemon.mountVolumes(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span>, err</span><br><span class="line">	&#125;</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	path = container.BaseFS.FromSlash(path)</span><br><span class="line">	<span class="comment">// 从请求中的 path 内容，获取其对应的宿主机上的路径 resolvedPath(/var/lib/docker/.../merged/&lt;path&gt;)</span></span><br><span class="line">	<span class="comment">// 和在容器文件系统中的绝对路径 absPath</span></span><br><span class="line">	resolvedPath, absPath, err := container.ResolvePath(path)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取容器中的文件 stat 信息，这里会进行一次符号链接解析，保存到 stat 的 LinkTarget 中</span></span><br><span class="line">	stat, err = container.StatPath(resolvedPath, absPath)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	driver := container.BaseFS</span><br><span class="line">	sourceDir, sourceBase := driver.Dir(resolvedPath), driver.Base(resolvedPath)</span><br><span class="line">	<span class="comment">// ?? 这里是什么意思 tar 的 rebasenames</span></span><br><span class="line">	<span class="comment">// 应该是将源文件打包的时候，在压缩包里重命名成 absPath 的 basename</span></span><br><span class="line">	<span class="comment">// 但是没有想到这样的场景，因为这里 sourceBase 应该和 Base(absPath) 一样吧？</span></span><br><span class="line">	opts := archive.TarResourceRebaseOpts(sourceBase, driver.Base(absPath))</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 对源文件进行打包</span></span><br><span class="line">	data, err := archivePath(driver, sourceDir, opts)</span><br><span class="line">	......</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 设置对应的 io.Readcloser</span></span><br><span class="line">	content = ioutils.NewReadCloserWrapper(data, <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">		err := data.Close()</span><br><span class="line">		container.DetachAndUnmount(daemon.LogVolumeEvent)</span><br><span class="line">		daemon.Unmount(container)</span><br><span class="line">		container.Unlock()</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> content, stat, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">archivePath</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;, src <span class="keyword">string</span>, opts *archive.TarOptions)</span> <span class="params">(io.ReadCloser, error)</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果 driver 实现了 archive 接口，则调用 driver.ArchivePath()</span></span><br><span class="line">	<span class="comment">// 目前只有 lcowfs 实现了这个接口</span></span><br><span class="line">	<span class="keyword">if</span> ap, ok := i.(archiver); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> ap.ArchivePath(src, opts)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 否则调用 archive.TarWithOptions</span></span><br><span class="line">	<span class="keyword">return</span> archive.TarWithOptions(src, opts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PUT 对应的调用链：<code>ContainerExtractToDir()</code> =&gt; <code>containerExtractToDir()</code> =&gt; <code>extractArchive()</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">ContainerExtractToDir</span><span class="params">(name, path <span class="keyword">string</span>, copyUIDGID, noOverwriteDirNonDir <span class="keyword">bool</span>, content io.Reader)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	container, err := daemon.GetContainer(name)</span><br><span class="line">	......</span><br><span class="line">	</span><br><span class="line">	err = daemon.containerExtractToDir(container, path, copyUIDGID, noOverwriteDirNonDir, content)</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(daemon *Daemon)</span> <span class="title">containerExtractToDir</span><span class="params">(container *container.Container, path <span class="keyword">string</span>, copyUIDGID, noOverwriteDirNonDir <span class="keyword">bool</span>, content io.Reader)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err = daemon.Mount(container); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	err = daemon.mountVolumes(container)</span><br><span class="line"></span><br><span class="line">	path = container.BaseFS.FromSlash(path)</span><br><span class="line">	driver := container.BaseFS</span><br><span class="line"></span><br><span class="line">	<span class="comment">// The destination path needs to be resolved to a host path, with all</span></span><br><span class="line">	<span class="comment">// symbolic links followed in the scope of the container&#x27;s rootfs. Note</span></span><br><span class="line">	<span class="comment">// that we do not use `container.ResolvePath(path)` here because we need</span></span><br><span class="line">	<span class="comment">// to also evaluate the last path element if it is a symlink. This is so</span></span><br><span class="line">	<span class="comment">// that you can extract an archive to a symlink that points to a directory.</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Consider the given path as an absolute path in the container.</span></span><br><span class="line">	absPath := archive.PreserveTrailingDotOrSeparator(</span><br><span class="line">		driver.Join(<span class="keyword">string</span>(driver.Separator()), path),</span><br><span class="line">		path,</span><br><span class="line">		driver.Separator())</span><br><span class="line"></span><br><span class="line">	<span class="comment">// This will evaluate the last path element if it is a symlink.</span></span><br><span class="line">	resolvedPath, err := container.GetResourcePath(absPath)</span><br><span class="line"></span><br><span class="line">	stat, err := driver.Lstat(resolvedPath)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> baseRel <span class="keyword">string</span></span><br><span class="line">	<span class="keyword">if</span> strings.HasPrefix(resolvedPath, <span class="string">`\\?\Volume&#123;`</span>) &#123;</span><br><span class="line">		......</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// baseRel 是相对于容器 rootfs 的相对路径</span></span><br><span class="line">		baseRel, err = driver.Rel(driver.Path(), resolvedPath)</span><br><span class="line">	&#125;</span><br><span class="line">	absPath = driver.Join(<span class="keyword">string</span>(driver.Separator()), baseRel)</span><br><span class="line">	......</span><br><span class="line">	options := daemon.defaultTarCopyOptions(noOverwriteDirNonDir)</span><br><span class="line">	<span class="keyword">if</span> err := extractArchive(driver, content, resolvedPath, options);err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">extractArchive</span><span class="params">(i <span class="keyword">interface</span>&#123;&#125;, src io.Reader, dst <span class="keyword">string</span>, opts *archive.TarOptions)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">// 如果 driver 实现了 archive 接口，则调用 driver.ArchivePath()</span></span><br><span class="line">	<span class="comment">// 目前只有 lcowfs 实现了该方法</span></span><br><span class="line">	<span class="keyword">if</span> ea, ok := i.(extractor); ok &#123;</span><br><span class="line">		<span class="keyword">return</span> ea.ExtractArchive(src, dst, opts)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 否则调用 chrootarchive.Untar</span></span><br><span class="line">	<span class="keyword">return</span> chrootarchive.Untar(src, dst, opts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="脆弱点"><a href="#脆弱点" class="headerlink" title="脆弱点"></a>脆弱点</h3><p>容器向宿主机的文件复制的关注点可以分为两阶段：</p>
<ul>
<li>容器中源文件路径解析</li>
<li>根据解析后的路径打开源文件</li>
</ul>
<p>宿主机向容器的文件复制的关注点可以分为两阶段：</p>
<ul>
<li>容器中目的文件路径解析</li>
<li>根据解析后的路径放入打包好的文件</li>
</ul>
<p>容器中路径的检查和解析（是否为符号链接，在第一步中）和最终的使用（在第二步中）存在时间差，能够造成 TOCTOU。</p>
<h4 id="容器-gt-宿主机"><a href="#容器-gt-宿主机" class="headerlink" title="容器 =&gt; 宿主机"></a>容器 =&gt; 宿主机</h4><p>eg: <code>docker cp &lt;container-id&gt;:/tmp/link-path/content</code><br><strong>阶段一：</strong><br>在容器文件向宿主机复制时，对于容器中源文件（目录）的检查（符号链接解析），在 dockerd 端的处理对 <code>/containers/&lt;containerID&gt;/archive?path=&lt;srcPath&gt;</code> 的 <code>GET</code> 请求过程中（<code>ContainerArchivePath()</code>=&gt;<code>containerArchivePath():212</code>=&gt;<code>ResolvePath():35</code>=&gt;<code>GetResourcePath()</code>）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GetResourcePath evaluates `path` in the scope of the container&#x27;s BaseFS, with proper path</span></span><br><span class="line"><span class="comment">// sanitisation. Symlinks are all scoped to the BaseFS of the container, as</span></span><br><span class="line"><span class="comment">// though the container&#x27;s BaseFS was `/`.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The BaseFS of a container is the host-facing path which is bind-mounted as</span></span><br><span class="line"><span class="comment">// `/` inside the container. This method is essentially used to access a</span></span><br><span class="line"><span class="comment">// particular path inside the container as though you were a process in that</span></span><br><span class="line"><span class="comment">// container.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// <span class="doctag">NOTE:</span> The returned path is *only* safely scoped inside the container&#x27;s BaseFS</span></span><br><span class="line"><span class="comment">//       if no component of the returned path changes (such as a component</span></span><br><span class="line"><span class="comment">//       symlinking to a different path) between using this method and using the</span></span><br><span class="line"><span class="comment">//       path. See symlink.FollowSymlinkInScope for more details.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(container *Container)</span> <span class="title">GetResourcePath</span><span class="params">(path <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span> &#123;</span><br><span class="line">	...</span><br><span class="line">	r, e := container.BaseFS.ResolveScopedPath(path, <span class="literal">false</span>)</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> r, e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的 <code>path</code> 参数，对应的是容器中源文件路径的  <code>dirPath</code> 也就是 <code>/tmp/link-path/</code>，对照函数的文档可以知道这里会返回：<strong>传入的容器中目录所对应的宿主机上的资源目录，如果 <strong><code>**path**</code></strong> 中存在符号链接，则以容器根目录（对应的宿主机目录）为 scope 来解析。</strong><br><strong>理想情况下</strong>，这里就是处理好了路径中存在符号链接 component 的情况，避免在使用时出现符号链接指向宿主机内容的问题。<br><strong>但如函数注释中的 NOTE 所示</strong>，所返回的路径中的 component 如果在 <strong>使用本函数</strong> 和 <strong>被使用</strong> 的间隙中存在改变（变成指向宿主机目录的符号链接），那么是<strong>不能保证所返回的路径是被安全限制在容器文件系统中</strong>的。<br><strong>阶段二：</strong><br>接着我们来关注其被<strong>使用的时机</strong>，在获得宿主机上对应的资源路径后，会将其路径中的 Dir 部分传入 archivePath()(containerArchivePath():241) 中：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-12139178629742304375-Z3GMGZc.png" alt="image.png"><br>继续向下调用 addTarFile()，filePath 内容为 sourceDir/源文件名：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-16342346950486818332-wfqsTO7.png" alt="image.png"><br>在其中会将容器中源文件打开，读取其内容：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-5453957759657135378-5kURjnj.png" alt="image.png"><br><strong>该函数会调用 open 系统调用来打开文件，这里的 path 是 attacker 可控的，可以为指向 host 上任何目录的符号链接。如果这时 path 路径 component 中存在符号链接，open 将会以宿主机根目录为 scope 对其解析，导致宿主机上的任意文件内容被打包起来用来复制。</strong></p>
<h4 id="容器-gt-宿主机-1"><a href="#容器-gt-宿主机-1" class="headerlink" title="容器 =&gt; 宿主机"></a>容器 =&gt; 宿主机</h4><p>eg: <code>docker cp &lt;container-id&gt;:/tmp/link-path/content</code><br><strong>阶段一：</strong><br>对容器中目的路径的解析在 dockerd 端的处理对 <code>/containers/&lt;containerID&gt;/archive?path=dirname(&lt;dstPath&gt;)</code> 的 <code>PUT</code> 请求过程中（<code>ContainerExtractToDir()</code>=&gt;<code>containerExtractToDir():303</code>=&gt;<code>GetResourcePath()</code>，与宿主机向容器的处理一致）。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-18158304585083929278-CZ72ttm.png" alt="image.png"><br><strong>返回目的路径对应在宿主机文件系统上的位置，并以容器根目录为 scope 进行了符号链接解析</strong>，将其保存在 resolvedPath 中<strong>。</strong>存在的安全风险也如 NOTE 所示。<br>并且紧跟一个 IsDir() 检查，检查所获的路径是否为一个正常目录(非符号链接)。<br><strong>阶段二：</strong><br>resolvedPath 传入 extractArchive() =&gt; … =&gt; invokeUnpack() 中<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-12222894952506993062-zSrlIeR.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-3072602734153273541-PSwFTqE.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-1355658677876296709-27xu213.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-563037672589001896-qNQId36.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-9234118281519383647-rqmhE0s.png" alt="image.png"><br>这里通过 reexec 机制，执行 docker-untar，并将 dest(刚刚传入的 resolvedPath) 作为参数。其对应的 handler 函数为 untar()：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-16626771195651321469-XDTNWtx.png" alt="image.png"><br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-9780811610076866401-e1GmKRT.png" alt="image.png"><br>这里的 flag.Arg(0) 就是阶段一中所获得的 resolvedPath，将其传入 chroot()，来改变当前进程的 root 目录和 cwd 目录，以便进行之后的解包操作。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-17414116944321740870-XpOE1Ie.png" alt="image.png"><br><strong>但是注意，这里的 path 是 attacker 可控的，有机会设置成指向 host 上任何目录的符号链接</strong>。<strong>由于 chroot 系统调用会对传入的路径中的符号链接进行解析，并且解析时的 scope 目录为宿主机根目录。所以此时 path 中的 component 可以为指向宿主机目录的符号链接，导致 chroot 目标为宿主机上任意目录，并将压缩包解压至该目录中，造成宿主机上任意文件写入。</strong></p>
<h3 id="利用过程"><a href="#利用过程" class="headerlink" title="利用过程"></a>利用过程</h3><p>这里的<strong>攻击场景</strong>是：</p>
<ul>
<li>一个非 root 用户/受限用户（执行的命令受限，eg：只能执行 docker cp）可以执行 docker cp 命令。</li>
<li>攻击者可以在容器中执行命令/可以定制容器镜像中的 entrypoint。</li>
</ul>
<ol>
<li>创建一个容器，在容器中准备 1 个正常目录 normal-dir/ 和 1 个指向 “/“ 的符号链接 link-dir/（目标目录可以更换成任意想读取/写入的宿主机文件路径）</li>
<li>使用 renameat2 系统调用不断交换上面准备的两个文件</li>
</ol>
<h4 id="容器-gt-宿主机-2"><a href="#容器-gt-宿主机-2" class="headerlink" title="容器 =&gt; 宿主机"></a>容器 =&gt; 宿主机</h4><ol start="3">
<li>在宿主机上执行 docker cp <container-id>:/…/normal-dir/<host_file_name>  <output_path></li>
<li>重复上一步，直到触发 TOCTOU，<strong>触发的条件</strong>是：在容器中源文件路径解析阶段调用<code>GetResourcePath()</code> 时，normal-dir/ 代表一个正常目录；而在打开源文件的阶段调用 <code>system.OpenSequential()</code> 时，normal-dir/ 代表一个符号链接文件</li>
<li>利用成功，符号链接指向目录下的 <host_file_name> 文件被复制到 <output_path> 位置，造成任意文件读取（普通用户借用了 dockerd 的高权限）</li>
</ol>
<p><em>实际利用中，发现如果最后一个目录项是符号链接的话，在 archivePath()=&gt;TarWithOptions() 中会因为 srcPath(符号链接) 的 IsDir() 为 false，导致 IncludeFiles 被替换，无法进入到 system.OpenSequential() 的分支中。并且在之后的 filepath.Walk() 中是不会跟踪符号链接的。这样导致利用时，将普通目录切换到符号链接的时机需要限制在 IsDir() 检查之后，filePath.Walk() 之前。</em><br><em>可以将切换目标调整到最后一个目录之前的其他目录来解决上述问题。</em></p>
<h4 id="宿主机-gt-容器"><a href="#宿主机-gt-容器" class="headerlink" title="宿主机 =&gt; 容器"></a>宿主机 =&gt; 容器</h4><ol start="3">
<li>在宿主机上执行 docker cp <src_path> <container-id>:/…/normal-dir/<host_file_name></li>
<li>重复上一步，直到触发 TOCTOU，<strong>触发的条件</strong>是：在容器中目的文件路径解析阶段调用 <code>GetResourcePath()</code>及 <code>isDir()</code> 时，normal-dir/ 代表一个正常目录；而在解包到目的路径阶段调用 <code>chroot()</code> 时，normal-dir/ 代表一个符号链接文件</li>
<li>利用成功，符号链接指向目录下的 <host_file_name> 文件被写入，写入内容为 <src_path> 的内容，造成任意文件写入（普通用户借用了 dockerd 的高权限）</li>
</ol>
<h2 id="poc"><a href="#poc" class="headerlink" title="poc"></a>poc</h2><p><a target="_blank" rel="noopener" href="https://github.com/Metarget/cloud-native-security-book/tree/main/code/0302-%E5%BC%80%E5%8F%91%E4%BE%A7%E6%94%BB%E5%87%BB/02-CVE-2018-15664/symlink_race">CVE-2018-15664 poc</a></p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p><strong>临时性修复方案：</strong><br><a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/39252">https://github.com/moby/moby/pull/39252</a><br>在 <code>containerStatPath()</code>、<code>containerArchivePath()</code> 等存在目录检查/使用时间差的函数中使用 docker pause 和 docker unpause 来冻结和解冻容器，避免在其时间差中的替换目录行为。<br><strong>补丁：</strong><br><a target="_blank" rel="noopener" href="https://github.com/moby/moby/pull/39292">https://github.com/moby/moby/pull/39292</a><br>在容器中打包/解包操作的过程中，chroot 到容器的 BaseFS(attacker 不可控) 中，限制 attacker 使用符号链接所能到达的范围。<br>容器内的打包也使用 chrootarchive 包。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li>核心问题是<strong>路径中存在符号链接</strong>，在解析时后的上下文在宿主机上的话就会有问题</li>
<li>符号链接可以绕过，容器目录拼接，目录字符串检查…<blockquote>
<p>来自 2023.3.2 今天发现之前修复的 kata 系统目录检查可以<strong>被目录符号链接绕过</strong>(非最后一个 component)，考虑把完整攻击链构造清楚了再报告。</p>
</blockquote>
</li>
<li>审计的时候可以注意一下：</li>
</ul>
<ol>
<li>容器可控的符号链接，解析的时机是不是宿主机上下文 </li>
<li>宿主机上下文中解析的符号链接，是否容器可控(CVE-2022-23648)</li>
</ol>
<ul>
<li>可以通过定制恶意镜像来实现漏洞的利用<br>将开发部署中常用的目录作为目标，在容器中用 entrypoint 开一个替换目录进程，等待受害者执行 docker cp，完成攻击。</li>
<li>审计思路<br>这里的问题出现在不可信的数据(attacker 可控的 path) 流入了敏感函数(open()/chroot())，做审计时，可以用这个规则粗略分析一下可能出现的风险点，看一下有没有做好限制。这个限制是否做好的标准还需要考虑(比如符号链接的情况)，过滤之后是否立即使用也会影响过滤效果（即使用 evalSymlink 净化之后，如果不立即使用，那么仍然是可控状态，target 变化成符号链接)，如果要做自动化的话。</li>
<li>TOCTOU 类问题<br>这类问题感觉会存在很多，怎么样批量找出这些问题呢？这个例子给的经验是，符号链接(尤其是路径符号链接)会导致目录解析一直是可控的，导致 TOCTOU 时间差中可以对路径做操作。</li>
</ul>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><ul>
<li><em>go 中的 io.ReadCloser 知识</em></li>
</ul>
<p>go 的基本 io 接口，ReadCloser 就是定义了 Read() （从数据流中读取字节流）和 Close() （关闭数据流）方法的接口，</p>
<ul>
<li><em>检查接口是否实现的方法</em></li>
</ul>
<p>变量名.(接口)，eg: <code>rc, ok := var1.(io.ReadCloser)</code></p>
<ul>
<li><em>docker 的 reexec 机制</em></li>
</ul>
<p>docker 通过 os/exec 包实现的的一种类似 fork 的机制。由于 go 屏蔽了进程、线程的概念，只提供了 goroutine 概念，导致无法像 c 一样使用 fork()。<br>同时，通过 reexec，docker 还可以提供一种动态注册子命令的方法，并且这些子命令是不向用户公开的(因为会通过 os.arg[0] 来判断子命令)。<br>首先，在 reexec 包里定义了一个全局变量，用来保存所有子命令；用 <code>Register()</code> 向其中注册子命令；在 <code>Init()</code> 中检查否有与 <code>os.Args[0]</code> 对应的子命令，如果有则调用注册进来的 handler 函数。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-15260055358437175063-JWf1gQN.png" alt="image.png"><br>像上面提到的 <code>docker-untar</code> 子命令就是通过 Register 方法注册进来的：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-2431708599458422890-NZmeXmF.png" alt="image.png"><br>在 docker 的 main 函数开头，会通过调用 reexec.Init() 来检查是否为子命令执行。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-10299532398297488887-yFdMp92.png" alt="image.png"><br>docker 在使用这些子命令时，通过 <code>reexec.Command()</code> 方法构造子命令 cmd（其 Path 指向的内容就是 docker 本身），将子命令内容及其参数通过 os/exec 包中的 <code>Cmd.Args</code> 传递。构造完毕后，通过 cmd.Start() 开始执行。<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-5048981215280088067-yGYgpJU.png" alt="image.png"></p>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="https://click.500team.cn">click</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://click.500team.cn/2022/11/04/CVE-2018-15664/">https://click.500team.cn/2022/11/04/CVE-2018-15664/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/CVE%E5%A4%8D%E7%8E%B0/">CVE复现</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2022/11/15/CVE-2019-14271/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">CVE-2019-14271 分析复现</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2022/10/20/CVE-2019-5736-%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/">
        <span class="next-text nav-default">CVE-2019-5736 分析复现</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:c1ick9917@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2020 - 2023<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">click</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
