<!DOCTYPE html>
<html lang="en">
  <head><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="description" content="35c3CTF namespace sandbox 分析"/><meta name="keywords" content="TODO, click's Blog" /><link rel="alternate" href="/atom.xml" title="click's Blog" type="application/atom+xml"><link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=2.11.0" />
<link rel="canonical" href="https://click.500team.cn/2022/10/01/35c3ctf/"/>

<link rel="stylesheet" type="text/css" href="/lib/fancybox/jquery.fancybox.css" />
<link rel="stylesheet" type="text/css" href="/css/style.css?v=2.11.0" />

<script id="baidu_push">
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
<script>
  window.config = {"leancloud":{"app_id":null,"app_key":null},"toc":true,"fancybox":true,"pjax":"","latex":false};
</script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/disqusjs@1.3/dist/disqusjs.css">


    <title>35c3CTF namespace sandbox 分析 - click's Blog</title>
  <meta name="generator" content="Hexo 5.4.0"></head>

  <body><div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/." class="logo">click's Blog</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>

<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list"><a href="/">
        <li class="mobile-menu-item">Home
          </li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags
          </li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About
          </li>
      </a></ul>
</nav>
<div class="container" id="mobile-panel">
      <header id="header" class="header"><div class="logo-wrapper">
  <a href="/." class="logo">click's Blog</a>
</div>

<nav class="site-navbar"><ul id="menu" class="menu"><li class="menu-item">
          <a class="menu-item-link" href="/">
            Home
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/tags/">
            Tags
            </a>
        </li>
      <li class="menu-item">
          <a class="menu-item-link" href="/about/">
            About
            </a>
        </li>
      </ul></nav>
</header>

      <main id="main" class="main">
        <div class="content-wrapper">
          <div id="content" class="content"><article class="post">
    <header class="post-header">
      <h1 class="post-title">35c3CTF namespace sandbox 分析
        </h1>

      <div class="post-meta">
        <span class="post-time">
          2022-10-01
        </span><span class="post-author">
          / click
        </span>
        </div>
    </header>

    <div class="post-toc" id="post-toc">
    <h2 class="post-toc-title">Contents</h2>
    <div class="post-toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE"><span class="toc-text">题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TL-DR"><span class="toc-text">TL;DR</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E9%A2%98%E7%9B%AE"><span class="toc-text">分析题目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#namespaces-%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E9%80%BB%E8%BE%91"><span class="toc-text">namespaces 可执行文件逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#chroot-%E9%80%83%E9%80%B8"><span class="toc-text">chroot 逃逸</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%BB%E5%BA%95%E9%80%83%E9%80%B8-chroot"><span class="toc-text">彻底逃逸 chroot</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">遇到的问题:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-text">相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#chroot-%E9%80%83%E9%80%B8-1"><span class="toc-text">chroot 逃逸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ptrace-%E6%B3%A8%E5%85%A5"><span class="toc-text">ptrace 注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%91%E7%9A%84%E6%80%9D%E8%80%83"><span class="toc-text">我的思考</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TODO"><span class="toc-text">TODO</span></a></li></ol>
    </div>
  </div><div class="post-content"><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>题目链接：<a target="_blank" rel="noopener" href="https://github.com/LevitatingLion/ctf-writeups/tree/master/35c3ctf/pwn_namespaces">https://github.com/LevitatingLion/ctf-writeups/tree/master/35c3ctf/pwn_namespaces</a><br>题目给出一个 Dockerfile 和一个 namespaces 二进制执行文件</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> tsuro/nsjail</span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> challenge/namespaces /home/user/chal</span></span><br><span class="line"><span class="comment">#这一句是模拟题解 flag 文件</span></span><br><span class="line"><span class="comment">#COPY tmpflag /flag </span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /bin/sh -c <span class="string">&quot;/usr/bin/setup_cgroups.sh &amp;&amp; cp /flag /tmp/flag &amp;&amp; chmod 400 /tmp/flag &amp;&amp; chown user /tmp/flag &amp;&amp; su user -c &#x27;/usr/bin/nsjail -Ml --port 1337 --chroot / -R /tmp/flag:/flag -T /tmp --proc_rw -U 0:1000:1 -U 1:100000:1 -G 0:1000:1 -G 1:100000:1 --keep_caps --cgroup_mem_max 209715200 --cgroup_pids_max 100 --cgroup_cpu_ms_per_sec 100 --rlimit_as max --rlimit_cpu max --rlimit_nofile max --rlimit_nproc max -- /usr/bin/stdbuf -i0 -o0 -e0 /usr/bin/maybe_pow.sh /home/user/chal&#x27;&quot;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="TL-DR"><a href="#TL-DR" class="headerlink" title="TL;DR"></a>TL;DR</h2><ul>
<li>题目程序的 Run_elf() 功能没有加入 sandbox 的 net ns</li>
<li>通过一个 unix socket 连接两个沙盒中进程，并通过其将一个沙盒的 root 目录文件描述符发送给另一个沙盒</li>
<li>使用这个外界文件描述符逃逸 chroot</li>
<li>在新的 sandbox 创建过程中，用一个指向<code>/</code> 的符号连接替换将要 chroot 的目标目录，由此获得一个unchroot 的进程<strong>（TOCTOU）</strong></li>
<li>创建一个新的 ns 获得 capabilities</li>
<li>使用 bind 挂载伪造一个<code>/proc/$pid/ns</code> 目录，从而在一个新加入的进程降权前控制它 ???</li>
<li>注入 shellcode 到上述新加入进程中，读取<code>flag</code></li>
</ul>
<h2 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h2><p>关注其进行了以下步骤：</p>
<ol>
<li>将题目中的 namespaces 文件拷贝到 /home/user/chal</li>
<li>执行一段 shell 命令<ol>
<li>设定 cgroups 限制（不重要）</li>
<li>将镜像中的 /flag 拷贝到 /tmp/flag</li>
<li>设置 /tmp/flag 权限 r–</li>
<li>设置 /tmp/flag 属主为 user (id 为 1000)</li>
<li>启动一个 nsjail 服务，监听 1337 端口来执行 maybe_pow.sh，具体参数解释如下  </li>
</ol>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">su user -c # 以 user 用户执行</span><br><span class="line">/usr/bin/nsjail </span><br><span class="line">    -Ml --port 1337 # 监听 1337 port</span><br><span class="line">    --chroot / # 没有切换根目录</span><br><span class="line">    -R /tmp/flag:/flag # 将 /tmp/flag 只读方式绑定挂载到 /flag</span><br><span class="line">    -T /tmp # 在 /tmp 处挂载一个 tmpfs</span><br><span class="line">    --proc_rw # 将 procfs 挂载为可读写模式</span><br><span class="line">    -U 0:1000:1 # 隔离环境内的 UID/GID 0和1 分别映射为环境外的 1000 和 100000</span><br><span class="line">    -U 1:100000:1 </span><br><span class="line">    -G 0:1000:1 </span><br><span class="line">    -G 1:100000:1 </span><br><span class="line">    --keep_caps # 保留所有 capablities</span><br><span class="line">    --cgroup_mem_max 209715200 </span><br><span class="line">    --cgroup_pids_max 100 </span><br><span class="line">    --cgroup_cpu_ms_per_sec 100 </span><br><span class="line">    --rlimit_as max </span><br><span class="line">    --rlimit_cpu max </span><br><span class="line">    --rlimit_nofile max </span><br><span class="line">    --rlimit_nproc max </span><br><span class="line">    -- /usr/bin/stdbuf -i0 -o0 -e0 /usr/bin/maybe_pow.sh /home/user/chal # 设置 input/output/error 输出无缓冲</span><br></pre></td></tr></table></figure>

<p>maybe_pow.sh 中的内容为: (这里的 pow… 均不重要，只关注 exec “$@”)，结合上面的参数也就是执行 /home/user/chal</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">if [ -f /pow ]; then # 如果 /pow 存在</span><br><span class="line">  POW=&quot;$(cat /pow)&quot;  # POW = /pow 的内容</span><br><span class="line">  if [ $&#123;POW&#125; != 0 ]; then # 如果 $POW 变量 != 0</span><br><span class="line">    if ! /usr/bin/pow.py ask &quot;$&#123;POW&#125;&quot;; then # 如果 &quot;pow.py ask $POW&quot; 执行返回值 == 0, 脚本退出</span><br><span class="line">      echo &#x27;pow fail&#x27;</span><br><span class="line">      exit 1</span><br><span class="line">    fi</span><br><span class="line">  fi</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">exec &quot;$@&quot; # 执行传入的参数</span><br></pre></td></tr></table></figure>

<p>这里通过 docker 将题目搭建起来，(因为需要设置 cgroups 限制，所以使用 –privileged 参数)。访问 1337 端口，发现其类似于 docker run/exec 的功能：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-3286347138440346285-CMF5H7Q.png" alt="image.png"></p>
<h2 id="namespaces-可执行文件逻辑"><a href="#namespaces-可执行文件逻辑" class="headerlink" title="namespaces 可执行文件逻辑"></a>namespaces 可执行文件逻辑</h2><p><del>通过逆向，</del>其主要逻辑为：<br><strong>main():</strong><br>主线程，给出命令提示 1\2\3，分别跳入对应线程，收到 &gt;=3 则退出</p>
<p><strong>Start_sandbox():</strong><br>选项1对应处理函数</p>
<ol>
<li>Fork 一个新进程使用全新的 namespace<ol>
<li>将父 user namespace 中的 userid 1 映射到新 user namespace 中的 userid 1（低权限用户)</li>
<li>父进程返回主循环，子进程继续执行</li>
</ol>
</li>
<li>读取用户提供的 init 二进制文件，将其加载到 memfd 中</li>
<li>创建目录 /tmp/chroots/$idx，(<strong>mode 777</strong>)，idx 是已创建 sandbox 的数量</li>
</ol>
<p><strong>这两步中间需要 TOCTOU</strong></p>
<ol start="4">
<li>chroot 到上述目录</li>
<li>通过 setresuid()/setresgid() 改变用户/用户组到 1（降权）</li>
<li>执行来自 memfd 的 init 二进制文件</li>
</ol>
<p><strong>Run_elf():</strong><br>选项2对应处理函数</p>
<ol>
<li>用户给定一个沙盒序号，并发送一段数据作为将要执行的 elf 文件</li>
<li>创建一个子进程<ol>
<li>父进程返回主循环，子进程继续执行</li>
</ol>
</li>
<li>子进程根据用户给定的沙盒序号找到沙盒内的初始进程（上面 start 输入的 elf 程序）</li>
<li>依次打开并加入 /proc/[初始进程PID]/ns/ 下的<strong>user、mnt、pid、uts、ipc 和 cgroup 命名空间（没有 net）</strong><br>[其中，在加入 pid 命名空间后执行了一次 fork，真正切换到目标 pid 命名空间（因为 pid namespace 比较特殊，当前进程的 pid namespace 并不会改变，只有子进程才会）, fork 后的父进程退出]</li>
<li>子进程（新的 pid ns）根据沙盒序号找到 /tmp/chroots/[沙盒序号]/，切换根目录到这里</li>
<li>通过 setresuid()/setresgid() 降权为 1 号用户</li>
<li>执行来自 memfd 的 elf 文件</li>
</ol>
<p>从 Run_elf() 处理逻辑中，很明显发现第 4 步依次加入 init process 的 ns 过程中，漏掉了 net ns，这会导致所有新加入的 process（包含不同沙盒中）共享所有网络接口和堆栈。</p>
<h2 id="chroot-逃逸"><a href="#chroot-逃逸" class="headerlink" title="chroot 逃逸"></a>chroot 逃逸</h2><p>上面的流程中可以看到，对于文件系统的隔离，sandbox 启用了新的 mnt ns，但没有在其中挂载新的根目录，只是使用了 chroot 来达到隔离的效果，而对于 chroot 的逃逸，只需要构造一个 chroot 之外的文件描述符即可（然后通过 openat 等借助文件描述符 + 相对地址的方式），这里有三种思路：</p>
<ul>
<li>在 chroot 环境中嵌套一个 chroot，同时保留一个第二层 chroot 之外的文件描述符</li>
<li>打开一个文件描述符，等待该文件被移出 chroot 环境，此时该文件描述符满足要求</li>
<li>从外界传入一个 chroot 环境外的文件描述符</li>
</ul>
<p>由于共享的 net ns，所以这里我们采用思路三，通过 unix socket 传递一个 chroot 环境外的文件描述符，来实现 chroot 逃逸。<br>这里我们无法通过 socket file 来实现通信，但可以通过绑定一个 unix domain socket 到抽象 socket 命名空间里的一个名称来实现通信。具体来说，使用 <code>SCM_RIGHTS</code> 类的 ancillary messages 实现发送文件描述符。<br>此时，新加入的 process 已经可以通过 <code>../</code> 访问到 chroot 环境之外的文件，但由于经过了降权 (0-&gt;1)，所以并不能直接读取 <code>/flag</code>。</p>
<blockquote>
<p>abstract socket namespace 允许我们将套接字绑定到文件系统上不可见的名称，和这里的 namespace 沙箱所指的 namespace 不是同一类。</p>
</blockquote>
<h2 id="彻底逃逸-chroot"><a href="#彻底逃逸-chroot" class="headerlink" title="彻底逃逸 chroot"></a>彻底逃逸 chroot</h2><p>上一步中，我们已经可以访问到 chroot 环境外的文件，但对于 chroot 环境的其他限制（不能创建新的 user ns，从而创建一个高权限空间（新的 namespace 中的 all cap + root））并没有解除。（因为 /proc/$$/root 不是当前 mnt ns 下的文件系统根目录）。<br>这里的沙盒父目录 <code>/tmp/chroots/</code> 权限是 <code>777</code>，是一个很明显的权限过松情况，配合上一步可以操作到 chroot 环境外文件的效果，可以将 /tmp/chroots/[sandbox_id]/ 目录删除，替换成一个指向 <code>/</code> 的符号链接，</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题:"></a>遇到的问题:</h2><blockquote>
<p>如果在沙盒1中打开当前进程根目录发送给沙盒2，那么沙盒2中的进程就能够以这个文件描述符加上相对路径调用 openat 打开沙盒外的文件</p>
</blockquote>
<p><em>为什么不能通过沙盒2的文件描述符来访问，沙盒1就可以?</em><br>这是一个经典的 chroot 逃逸，分析见下节。</p>
<blockquote>
<p>接着它加入的pid命名空间实际上属于init的子进程</p>
</blockquote>
<p><em>init 的子进程和 init 进程不是同一个 pid ns 吗?</em><br>根据后面描述的 ptrace 要求来看，这里的子进程应该新建了一个 pid ns。</p>
<blockquote>
<ol>
<li>这样一来，init 子进程就能够在这个pid命名空间下借助ptrace向未降权的 run_elf 进程注入代码并执行了。</li>
<li>为了ptrace，init 进程必须新建一个 pid 命名空间</li>
</ol>
</blockquote>
<p><em>ptrace 的条件?</em><br>To be able to ptrace the process, it has to be in the same pid namespace as us and we have to have the CAP_SYS_PTRACE capability.</p>
<ol>
<li>调试进程要和被调试进程在一个 pid ns 中（被调试应该可以有更下层的 pid ns，会被映射到上层 pid ns 中）</li>
<li>调试者需要有 CAP_SYS_PTRACE</li>
</ol>
<blockquote>
<p>chroot 过的进程不被允许创建新的 user 命名空间来获得 CAP_SYS_ADMIN 权限</p>
</blockquote>
<p><em>不允许创建新的 user ns 还是创建后不能获得 cap_sys_admin? 创建新的 user ns 会获得哪些 cap?</em><br><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/442996/what-rule-prevents-entering-a-user-namespace-from-inside-a-chroot">prevents entering a user namespace from inside a chroot</a><br>chroot 前后，cap_sys_admin 不会变化。<br>chroot 过的进程不允许创建新的 user namespace。众所周知，在具有 CAP_SYS_CHROOT 的情况下，chroot 逃逸非常轻松（通过嵌套一个 chroot），而新的 user ns 会将全部 cap 赋予一个普通 uid（外部视角来看），这会导致一个普通用户逃逸 chroot。<br>同时可以在 <code>man 2 clone</code>，<code>man 2 unshare</code> 中看到对应描述：</p>
<blockquote>
<p>EPERM (since Linux 3.9)<br>CLONE_NEWUSER was specified in the flags mask and the<br>caller is in a chroot environment (i.e., the caller’s root<br>directory does not match the root directory of the mount<br>namespace in which it resides).</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://tinylab.org/user-namespace/">https://tinylab.org/user-namespace/</a><br>新创建一个 user namespace 会重新规划这个 ns 的 capability 能力，和这个 user namespace 父辈的 capability 能力无关。在新 user namespace 中 uid 0 等于 root 默认拥有所有 capability，普通用户的 capability 是在 exec() 时由 task-&gt;real_cred-&gt;cap_inheritable + file capability 综合而成。</p>
<h2 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h2><h3 id="chroot-逃逸-1"><a href="#chroot-逃逸-1" class="headerlink" title="chroot 逃逸"></a>chroot 逃逸</h3><p><a target="_blank" rel="noopener" href="https://github.com/earthquake/chw00t">https://github.com/earthquake/chw00t</a><br>chroot 逃逸的成因是使用一个 root_path 之外的文件描述符，对其使用 .. 相对路径，可以越过 root_path 的限制。因为该描述符在进程的 root_path(从 /proc/xxx/root 中查看指向 “/../“) 之外，所以原始的 root dir 是这个进程能找到的下一个 root barrier，使用 .. 可以一直跳到此 root barrier 为止。<br>至于为什么不能从 docker container 中逃逸到宿主机，除了执行权限等因素外，是因为在 container 视图的 mount 树中，overlay 挂载点是其 root 节点（从/proc/xx/root 中查看指向 “/“），作用相当于一个 root barrier。（这里需要看源码深入分析下）<br>而题目这里只使用了 chroot 来切换 root 目录，虽然也进入了新的 mnt ns，但并没有挂载新的根目录（需要了解一下 docker run 的流程，pivot_root的安全性）<br><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/456620/how-to-perform-chroot-with-linux-namespaces">chroot 和 pivot_root</a><br>对于其源码分析和 mnt namespace 隔离的情况，需要看一下内核 lookup/openat 文件打开流程相关的函数</p>
<p>chroot 的 man page：<br><img src="https://b3logfile.com/file/2023/03/solo-fetchupload-7011856655724033912-FY9x1Yz.png" alt="image.png"><br>最经典的情况：chroot 对具有 CAP_SYS_CHROOT 的进程/用户是不存在限制的，可以通过简单的二次 chroot(目的也是<strong>获得一个 chroot 外的文件描述符</strong>) 来逃逸。</p>
<h3 id="ptrace-注入"><a href="#ptrace-注入" class="headerlink" title="ptrace 注入"></a>ptrace 注入</h3><p>ptrace 的条件：</p>
<blockquote>
<p>To be able to ptrace the process, it has to be in the same pid namespace as us and we have to have the CAP_SYS_PTRACE capability.</p>
</blockquote>
<ol>
<li>调试进程要和被调试进程在一个 pid ns 中（被调试应该可以有更下层的 pid ns，会被映射到上层 pid ns 中）</li>
<li>调试者需要有 CAP_SYS_PTRACE</li>
</ol>
<h2 id="我的思考"><a href="#我的思考" class="headerlink" title="我的思考"></a>我的思考</h2><ul>
<li>依次打开、加入、打开、加入 /proc/[init 进程 pid]/ns/ 下的 namespace 是不正常的，感觉很少有这种情况吧，因为 setns 加入到新的 mnt ns 之后，进程的根文件系统会变化到容器的不可信环境中。<em>会吗？实验一下<br>倒是有可能有这种情况，依次调用 setns</em></li>
</ul>
<ul>
<li>能不能先在容器外打开文件描述符，然后进入 ns (mnt)后，再访问呢?</li>
</ul>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><ul>
<li>linux 文件知识，做下笔记</li>
<li>实验未 chroot 时能不能通过新建。。<br>可以，新建 usernamespace 不需要任何 cap，创建好的 user ns 中的 root（被映射的）会带有所有 cap</li>
<li>实验 chroot 之后能不能通过新建 usernamespace 来获得 sys_cap_admin<br>不能, <a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/442996/what-rule-prevents-entering-a-user-namespace-from-inside-a-chroot">https://unix.stackexchange.com/questions/442996/what-rule-prevents-entering-a-user-namespace-from-inside-a-chroot</a></li>
<li>ptrace 条件，为什么需要新建 pid ns<br>(1) 调试进程要和被调试进程在一个 pid ns 中（被调试应该可以有更下层的 pid ns，会被映射到上层 pid ns 中）<br>(2) 调试者需要有该 pid ns 中的 CAP_SYS_PTRACE</li>
<li>分析题解代码</li>
</ul>

      </div>
      <div class="post-copyright">
    <p class="copyright-item">
      <span>Author: </span>
      <a href="https://click.500team.cn">click</a>
    </p>
    <p class="copyright-item">
      <span>Link: </span>
      <a href="https://click.500team.cn/2022/10/01/35c3ctf/">https://click.500team.cn/2022/10/01/35c3ctf/</a>
    </p>
    <p class="copyright-item">
      <span>License: </span><a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>
    </p>
  </div>
      <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/TODO/">TODO</a>
            </div>
        
        <nav class="post-nav"><a class="prev" href="/2022/10/20/CVE-2019-5736-%E5%88%86%E6%9E%90%E5%A4%8D%E7%8E%B0/">
        <i class="iconfont icon-left"></i>
        <span class="prev-text nav-default">CVE-2019-5736 分析复现</span>
        <span class="prev-text nav-mobile">Prev</span>
      </a>
    <a class="next" href="/2022/06/19/Firecracker-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/">
        <span class="next-text nav-default">Firecracker 环境配置</span>
        <span class="prev-text nav-mobile">Next</span>
        <i class="iconfont icon-right"></i>
      </a>
    </nav></footer>
    </article></div><div class="comments" id="comments"></div></div>
      </main>

      <footer id="footer" class="footer"><div class="social-links"><a href="mailto:c1ick9917@gmail.com" class="iconfont icon-email" title="email"></a>
        <a href="/atom.xml" class="iconfont icon-rss" title="rss"></a>
    </div><div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" target="_blank" rel="noopener" href="https://github.com/ahonn/hexo-theme-even">Even</a>
  </span>

  <span class="copyright-year">&copy;2020 - 2023<span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author">click</span>
  </span>
</div>
</footer>

      <div class="back-to-top" id="back-to-top">
        <i class="iconfont icon-up"></i>
      </div>
    </div><script type="text/javascript" src="/lib/jquery/jquery.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/src/even.js?v=2.11.0"></script>
</body>
</html>
