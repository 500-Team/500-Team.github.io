---
title: CVE-2018-15664 分析复现
date: 2022-11-4 15:31:23
tags: CVE复现
author: click
---
## 漏洞分析

### docker cp 实现流程

_docker-ce 项目拆分后，各组件指向其各自的仓库，cli 端项目为 `docker/cli`，engine 端项目为 `moby/moby`，这里我用的 commit 节点为 [docker/docker-ce/e4666ebe817a064c62abf0339d5679868d063148](https://github.com/docker/docker-ce/tree/e4666ebe817a064c62abf0339d5679868d063148)，也是修复 CVE-2018-15664 前的最后一次 commit。_
_在下面的源码分析流程可以大致看出对于一个 docker 命令，应该怎么跟踪它的源码。_

#### cli 端

_指 docker 命令行_
在 docker client 端，所有 docker 子命令都由 cobra 定义，对应定义的内容如下：

```go
func AddCommands(cmd *cobra.Command, dockerCli command.Cli) {
	......
	// container 子命令
	container.NewContainerCommand(dockerCli),
	container.NewRunCommand(dockerCli),
	......
}
```

```go
func NewContainerCommand(dockerCli command.Cli) *cobra.Command {
	......
	cmd.AddCommand(
		......
		// 对应 docker container cp 命令
		NewCopyCommand(dockerCli),
		......
	)
}
```

```go
func NewCopyCommand(dockerCli command.Cli) *cobra.Command {
	......
	cmd := &cobra.Command{
		......
		// 绑定对应的 handler 函数
		RunE: func(cmd *cobra.Command, args []string) error {
			......
			opts.source = args[0]
			opts.destination = args[1]
			return runCopy(dockerCli, opts)
		},
	}
}
```

可以看到，cli 的 copy 命令由 `runCopy()` 执行。其定义如下：

```go
func runCopy(dockerCli command.Cli, opts copyOptions) error {
	srcContainer, srcPath := splitCpArg(opts.source)
	destContainer, destPath := splitCpArg(opts.destination)

	copyConfig := cpConfig{
		followLink: opts.followLink,
		copyUIDGID: opts.copyUIDGID,
		quiet:      opts.quiet,
		sourcePath: srcPath,
		destPath:   destPath,
	}
	// 确定 cp 方向
	var direction copyDirection
	if srcContainer != "" {
		direction |= fromContainer
		copyConfig.container = srcContainer
	}
	if destContainer != "" {
		direction |= toContainer
		copyConfig.container = destContainer
	}

	ctx := context.Background()

	switch direction {
	// 从容器复制到宿主机
	case fromContainer:
		return copyFromContainer(ctx, dockerCli, copyConfig)
	// 从宿主机复制到容器
	case toContainer:
		return copyToContainer(ctx, dockerCli, copyConfig)
	case acrossContainers:
		return errors.New("copying between containers is not supported")
	default:
		return errors.New("must specify at least one container source")
	}
}
```

当复制方向为从容器拷贝到宿主机时，调用 `copyFromContainer()`，反之调用 `copyToContainer()`。
`copyFromContainer()` 定义如下：

```go
func copyFromContainer(ctx context.Context, dockerCli command.Cli, copyConfig cpConfig) (err error) {
	dstPath := copyConfig.destPath
	srcPath := copyConfig.sourcePath
	......

	// 如果命令行传入了 -L/--follow-link 参数，则处理 srcPath 的符号链接
	if copyConfig.followLink {
		srcStat, err := client.ContainerStatPath(ctx, copyConfig.container, srcPath)
		// 判断是 src 文件是否为符号链接文件，是则解析符号链接内容
		if err == nil && srcStat.Mode&os.ModeSymlink != 0 {
			// linkTarget 是相对于容器 rootfs 的路径
			linkTarget := srcStat.LinkTarget
			...
			// rebaseName 保存的是传入的 srcPath 的 basename，和符号链接所指向的实际文件 basename 可能不同
			linkTarget, rebaseName = archive.GetRebaseName(srcPath, linkTarget)
			srcPath = linkTarget
		}
	}
	......

	// 从容器中取出所复制内容
	content, stat, err := client.CopyFromContainer(ctx, copyConfig.container, srcPath)
	......

	// 复制源文件信息
	srcInfo := archive.CopyInfo{
		Path:       srcPath,  // 实际复制源文件 path
		Exists:     true,
		IsDir:      stat.Mode.IsDir(),
		RebaseName: rebaseName, 
	}

	preArchive := content
	// 处理 rebaseName 非空的情况（src 文件为符号链接，且使用了 --follow-link 参数）
	if len(srcInfo.RebaseName) != 0 {
		_, srcBase := archive.SplitPathDirEntry(srcInfo.Path)
		preArchive = archive.RebaseArchiveEntries(content, srcBase, srcInfo.RebaseName)
	}
	// 把容器中取出的内容，复制到 dstPath（dstPath 的符号链接问题会在这里面处理）
	return archive.CopyTo(preArchive, srcInfo, dstPath)
}
```

1. 如果使用了 `-L/--follow-link` 参数，处理容器中源文件是符号链接的情况
2. 调用 `client.CopyFromContainer()` 获取打包好的 content(tar 包)
3. 调用 `archive.CopyTo()` 把 content 的内容解包到 dstPath

当复制方向为从宿主机到容器时，调用 `copyToContainer()`，定义如下：

```go
func copyToContainer(ctx context.Context, dockerCli command.Cli, copyConfig cpConfig) (err error) {
	......
	
	dstStat, err := client.ContainerStatPath(ctx, copyConfig.container, dstPath)
	// 处理容器中的 dst 文件的符号链接（这里不需要设置 -L/--follow-link 参数）
	if err == nil && dstStat.Mode&os.ModeSymlink != 0 {
		// 如果容器中 dst 文件为符号链接文件，则将 dstInfo.Path 设为所指向的路径
		// CVE-2018-15664：这里的 TOCTOU 问题，在这里检查了容器中文件的 symlink 情况，poc 需要在这里没有解析 symlink
		// 不对，这里判断的是最终的文件是否为符号链接，我们利用的是路径中的目录是符号链接的情况，这里不会影响
		linkTarget := dstStat.LinkTarget
		......
		dstInfo.Path = linkTarget
		dstStat, err = client.ContainerStatPath(ctx, copyConfig.container, linkTarget)
	}
	
	if srcPath == "-" {
		......
	} else {
		// Prepare source copy info.
		// 为 archive 复制准备 CopyInfo 结构体
		// 对于 -L/--follow-link 的处理逻辑在其中（解析 srcPath 的符号链接）
		srcInfo, err := archive.CopyInfoSourcePath(srcPath, copyConfig.followLink)
		......

		// 将宿主机上的源文件打包成 Tar
		srcArchive, err := archive.TarResource(srcInfo)
		......

		// 处理 cp 的几种情况（cp 目录/目录以存在/..），决定最终的复制 dst 路径
		// CVE-2018-15664：poc 这里应该是 dstDir.Exists == true && dstDir.IsDir == true
		dstDir, preparedArchive, err := archive.PrepareArchiveCopy(srcArchive, srcInfo, dstInfo)
		resolvedDstPath = dstDir
		content = preparedArchive
		......

		// 调用 client 将打包的数据流传到容器中
		return client.CopyToContainer(ctx, copyConfig.container, resolvedDstPath, content, options)
	}
```

1. 处理容器中目的文件是符号链接的情况
2. 将宿主机上的源文件打包
3. 调用 `client.CopyToContainer()` 将打包的数据传到容器中

#### client 端

_指向 dockerd 监听端口发送请求的一方_
在 client 端，对应上面两种复制方向，可以看到所调用的两个函数分别为 `CopyFromContainer()` 和 `CopyToContainer()`。同时，两种方向都调用了 client 端的 `ContainerStatPath()` 函数来获取容器中文件的 stat 信息。
`ContainerStatPath()` 负责获取容器中文件的 stat 信息，定义如下：

```go
func (cli *Client) ContainerStatPath(ctx context.Context, containerID, path string) (types.ContainerPathStat, error) {
	query := url.Values{}
	query.Set("path", filepath.ToSlash(path)) // Normalize the paths used in the API.

	urlStr := "/containers/" + containerID + "/archive"
	// 构造了一个向 dockerd 监听端口的 /containers/<containerID>/archive?path=<path>
	// 的 HEAD 请求
	response, err := cli.head(ctx, urlStr, query, nil)
	......
	
	return getContainerPathStatFromHeader(response.header)
}
```

`CopyFromContainer()` 负责获取容器中的源文件内容，并将其以一个 TAR archive Reader 的形式返回，定义如下：

```go
func (cli *Client) CopyFromContainer(ctx context.Context, containerID, srcPath string) (io.ReadCloser, types.ContainerPathStat, error) {
	query := make(url.Values, 1)
	query.Set("path", filepath.ToSlash(srcPath)) // Normalize the paths used in the API.

	apiPath := "/containers/" + containerID + "/archive"
	// 构造了一个向 dockerd 监听端口的 /containers/<containerID>/archive?path=<srcPath> 
	// 的 GET 请求
	response, err := cli.get(ctx, apiPath, query, nil)
	......

	// 获取容器中源文件的 stat 信息
	stat, err := getContainerPathStatFromHeader(response.header)
	......

	return response.body, stat, err
}
```

`CopyToContainer()` 负责将 TAR archive Reader 形式的文件内容复制到容器文件系统中，定义如下：

```go
func (cli *Client) CopyToContainer(ctx context.Context, containerID, dstPath string, content io.Reader, options types.CopyToContainerOptions) error {
	query := url.Values{}
	query.Set("path", filepath.ToSlash(dstPath)) 
	......

	apiPath := "/containers/" + containerID + "/archive"
	// 构造了一个向 dockerd 监听端口的 /containers/<containerID>/archive?path=dirname(<dstPath>) 
	// 的 put 请求, body 为源文件内容
	response, err := cli.putRaw(ctx, apiPath, query, content, nil)
	......

	return nil
}
```

#### dockerd 端

_指监听 socket 端口的一方_
在 dockerd 端，对 /containers/* 的请求路由规则在 `engine/api/server/router/container/container.go` 中的 `initRoutes()` 中指定。
对 `containers/<containerID>/archive` 的 :

- HEAD 请求会路由到 `headContainersArchive()`, 核心调用 `s.backend.ContainerStatPath()`
- GET 请求对应 `getContainersArchive()`, 核心调用`s.backend.ContainerArchivePath()`
- PUT 请求对应 `putContainersArchive()`, 核心调用` s.backend.ContainerExtractToDir()`

HEAD 对应的调用链：`ContainerStatPath()` => `containerStatPath()` => `StatPath()`

```go
func (daemon *Daemon) ContainerStatPath(name string, path string) (stat *types.ContainerPathStat, err error) {
	container, err := daemon.GetContainer(name)
	......

	stat, err = daemon.containerStatPath(container, path)
	if err == nil {
		return stat, nil
	}
	......
}
```

```go
func (daemon *Daemon) containerStatPath(container *container.Container, path string) (stat *types.ContainerPathStat, err error) {
	......
	// 挂载容器的根文件系统
	// 如果是正在运行的容器，那挂载点就是已有的 /var/lib/docker/overlay2/.../merged/
	// 如果容器没有在运行，那就需要暂时将 overlay fs 挂载上来，挂载点和上面的一样，复制完成后再 unmount
	// container.BaseFS = dir ==> (Path() => /var/lib/docker/overlay2/.../merged/)
	if err = daemon.Mount(container); err != nil {
		return nil, err
	}
	......
	// 挂载容器中的存储卷，也就是在容器中的 mount（不包括伪文件系统，可以通过 docker inspect 查看）
	err = daemon.mountVolumes(container)
	......
	// Normalize path before sending to rootfs
	path = container.BaseFS.FromSlash(path)
	// 返回 path(in container) 对应在宿主机上的绝对路径、相对容器文件系统的绝对路径
	// 如果 path 指向容器根文件系统外，则返回 err
	resolvedPath, absPath, err := container.ResolvePath(path)
	......
	return container.StatPath(resolvedPath, absPath)
}
```

```go
// the given path should be fully resolved to a path on the host corresponding 
// to the given absolute path inside the container.
func (container *Container) StatPath(resolvedPath, absPath string) (stat *types.ContainerPathStat, err error) {
	......
	driver := container.BaseFS
	// resolvedPath 是相对于宿主机文件系统的路径
	lstat, err := driver.Lstat(resolvedPath)

	// 有一次符号链接处理的逻辑，将指向的目标保存到 linkTarget（相对于容器 rootfs 的路径）
	var linkTarget string
	if lstat.Mode()&os.ModeSymlink != 0 {
		// Fully evaluate the symlink in the scope of the container rootfs.
		// 在这里解析符号链接指向的路径（相对于容器文件系统）
		hostPath, err := container.GetResourcePath(absPath)

		// 求相对于容器 rootfs 的相对路径
		linkTarget, err = driver.Rel(driver.Path(), hostPath)

		// Make it an absolute path.
		linkTarget = driver.Join(string(driver.Separator()), linkTarget)
	}

	return &types.ContainerPathStat{
		Name:       driver.Base(absPath),
		Size:       lstat.Size(),
		Mode:       lstat.Mode(),
		Mtime:      lstat.ModTime(),
		LinkTarget: linkTarget,
	}, nil
}
```

GET 对应的调用链：`ContainerArchivePath()` => `containerArchivePath()` => `archivePath()`

```go
func (daemon *Daemon) ContainerArchivePath(name string, path string) (content io.ReadCloser, stat *types.ContainerPathStat, err error) {
	// 通过 containerId 获取对应容器对象 (*container.Container)
	container, err := daemon.GetContainer(name)
	......

	// 打包容器中的源文件
	content, stat, err = daemon.containerArchivePath(container, path)
	if err == nil {
		return content, stat, nil
	}
	......
}
```

```go
func (daemon *Daemon) containerArchivePath(container *container.Container, path string) (content io.ReadCloser, stat *types.ContainerPathStat, err error) {
	......

	// 挂载容器根文件系统
	if err = daemon.Mount(container); err != nil {
		return nil, nil, err
	}
	......
	// 挂载容器中的存储卷
	if err = daemon.mountVolumes(container); err != nil {
		return nil, nil, err
	}
	......

	path = container.BaseFS.FromSlash(path)
	// 从请求中的 path 内容，获取其对应的宿主机上的路径 resolvedPath(/var/lib/docker/.../merged/<path>)
	// 和在容器文件系统中的绝对路径 absPath
	resolvedPath, absPath, err := container.ResolvePath(path)
	......

	// 获取容器中的文件 stat 信息，这里会进行一次符号链接解析，保存到 stat 的 LinkTarget 中
	stat, err = container.StatPath(resolvedPath, absPath)
	......

	driver := container.BaseFS
	sourceDir, sourceBase := driver.Dir(resolvedPath), driver.Base(resolvedPath)
	// ?? 这里是什么意思 tar 的 rebasenames
	// 应该是将源文件打包的时候，在压缩包里重命名成 absPath 的 basename
	// 但是没有想到这样的场景，因为这里 sourceBase 应该和 Base(absPath) 一样吧？
	opts := archive.TarResourceRebaseOpts(sourceBase, driver.Base(absPath))

	// 对源文件进行打包
	data, err := archivePath(driver, sourceDir, opts)
	......

	// 设置对应的 io.Readcloser
	content = ioutils.NewReadCloserWrapper(data, func() error {
		err := data.Close()
		container.DetachAndUnmount(daemon.LogVolumeEvent)
		daemon.Unmount(container)
		container.Unlock()
		return err
	})
	
	return content, stat, nil
}
```

```go
func archivePath(i interface{}, src string, opts *archive.TarOptions) (io.ReadCloser, error) {
	// 如果 driver 实现了 archive 接口，则调用 driver.ArchivePath()
	// 目前只有 lcowfs 实现了这个接口
	if ap, ok := i.(archiver); ok {
		return ap.ArchivePath(src, opts)
	}
	// 否则调用 archive.TarWithOptions
	return archive.TarWithOptions(src, opts)
}
```

PUT 对应的调用链：`ContainerExtractToDir()` => `containerExtractToDir()` => `extractArchive()`

```go
func (daemon *Daemon) ContainerExtractToDir(name, path string, copyUIDGID, noOverwriteDirNonDir bool, content io.Reader) error {
	container, err := daemon.GetContainer(name)
	......
	
	err = daemon.containerExtractToDir(container, path, copyUIDGID, noOverwriteDirNonDir, content)
	......
}
```

```go
func (daemon *Daemon) containerExtractToDir(container *container.Container, path string, copyUIDGID, noOverwriteDirNonDir bool, content io.Reader) (err error) {
	if err = daemon.Mount(container); err != nil {
		return err
	}
	err = daemon.mountVolumes(container)

	path = container.BaseFS.FromSlash(path)
	driver := container.BaseFS

	// The destination path needs to be resolved to a host path, with all
	// symbolic links followed in the scope of the container's rootfs. Note
	// that we do not use `container.ResolvePath(path)` here because we need
	// to also evaluate the last path element if it is a symlink. This is so
	// that you can extract an archive to a symlink that points to a directory.

	// Consider the given path as an absolute path in the container.
	absPath := archive.PreserveTrailingDotOrSeparator(
		driver.Join(string(driver.Separator()), path),
		path,
		driver.Separator())

	// This will evaluate the last path element if it is a symlink.
	resolvedPath, err := container.GetResourcePath(absPath)

	stat, err := driver.Lstat(resolvedPath)

	var baseRel string
	if strings.HasPrefix(resolvedPath, `\\?\Volume{`) {
		......
	} else {
		// baseRel 是相对于容器 rootfs 的相对路径
		baseRel, err = driver.Rel(driver.Path(), resolvedPath)
	}
	absPath = driver.Join(string(driver.Separator()), baseRel)
	......
	options := daemon.defaultTarCopyOptions(noOverwriteDirNonDir)
	if err := extractArchive(driver, content, resolvedPath, options);err != nil {
		return err
	}
```

```go
func extractArchive(i interface{}, src io.Reader, dst string, opts *archive.TarOptions) error {
	// 如果 driver 实现了 archive 接口，则调用 driver.ArchivePath()
	// 目前只有 lcowfs 实现了该方法
	if ea, ok := i.(extractor); ok {
		return ea.ExtractArchive(src, dst, opts)
	}
	// 否则调用 chrootarchive.Untar
	return chrootarchive.Untar(src, dst, opts)
}
```

### 脆弱点

容器向宿主机的文件复制的关注点可以分为两阶段：

- 容器中源文件路径解析
- 根据解析后的路径打开源文件

宿主机向容器的文件复制的关注点可以分为两阶段：

- 容器中目的文件路径解析
- 根据解析后的路径放入打包好的文件

容器中路径的检查和解析（是否为符号链接，在第一步中）和最终的使用（在第二步中）存在时间差，能够造成 TOCTOU。

#### 容器 => 宿主机

eg: `docker cp <container-id>:/tmp/link-path/content`
**阶段一：**
在容器文件向宿主机复制时，对于容器中源文件（目录）的检查（符号链接解析），在 dockerd 端的处理对 `/containers/<containerID>/archive?path=<srcPath>` 的 `GET` 请求过程中（`ContainerArchivePath()`=>`containerArchivePath():212`=>`ResolvePath():35`=>`GetResourcePath()`）：

```go
// GetResourcePath evaluates `path` in the scope of the container's BaseFS, with proper path
// sanitisation. Symlinks are all scoped to the BaseFS of the container, as
// though the container's BaseFS was `/`.
//
// The BaseFS of a container is the host-facing path which is bind-mounted as
// `/` inside the container. This method is essentially used to access a
// particular path inside the container as though you were a process in that
// container.
//
// NOTE: The returned path is *only* safely scoped inside the container's BaseFS
//       if no component of the returned path changes (such as a component
//       symlinking to a different path) between using this method and using the
//       path. See symlink.FollowSymlinkInScope for more details.
func (container *Container) GetResourcePath(path string) (string, error) {
	...
	r, e := container.BaseFS.ResolveScopedPath(path, false)
	
	return r, e
}
```

这里传入的 `path` 参数，对应的是容器中源文件路径的  `dirPath` 也就是 `/tmp/link-path/`，对照函数的文档可以知道这里会返回：**传入的容器中目录所对应的宿主机上的资源目录，如果 **`**path**`** 中存在符号链接，则以容器根目录（对应的宿主机目录）为 scope 来解析。**
**理想情况下**，这里就是处理好了路径中存在符号链接 component 的情况，避免在使用时出现符号链接指向宿主机内容的问题。
**但如函数注释中的 NOTE 所示**，所返回的路径中的 component 如果在 **使用本函数** 和 **被使用** 的间隙中存在改变（变成指向宿主机目录的符号链接），那么是**不能保证所返回的路径是被安全限制在容器文件系统中**的。
**阶段二：**
接着我们来关注其被**使用的时机**，在获得宿主机上对应的资源路径后，会将其路径中的 Dir 部分传入 archivePath()(containerArchivePath():241) 中：
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-12139178629742304375-Z3GMGZc.png)
继续向下调用 addTarFile()，filePath 内容为 sourceDir/源文件名：
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-16342346950486818332-wfqsTO7.png)
在其中会将容器中源文件打开，读取其内容：
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-5453957759657135378-5kURjnj.png)
**该函数会调用 open 系统调用来打开文件，这里的 path 是 attacker 可控的，可以为指向 host 上任何目录的符号链接。如果这时 path 路径 component 中存在符号链接，open 将会以宿主机根目录为 scope 对其解析，导致宿主机上的任意文件内容被打包起来用来复制。**

#### 容器 => 宿主机

eg: `docker cp <container-id>:/tmp/link-path/content`
**阶段一：**
对容器中目的路径的解析在 dockerd 端的处理对 `/containers/<containerID>/archive?path=dirname(<dstPath>)` 的 `PUT` 请求过程中（`ContainerExtractToDir()`=>`containerExtractToDir():303`=>`GetResourcePath()`，与宿主机向容器的处理一致）。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-18158304585083929278-CZ72ttm.png)
**返回目的路径对应在宿主机文件系统上的位置，并以容器根目录为 scope 进行了符号链接解析**，将其保存在 resolvedPath 中**。**存在的安全风险也如 NOTE 所示。
并且紧跟一个 IsDir() 检查，检查所获的路径是否为一个正常目录(非符号链接)。
**阶段二：**
resolvedPath 传入 extractArchive() => ... => invokeUnpack() 中
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-12222894952506993062-zSrlIeR.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-3072602734153273541-PSwFTqE.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-1355658677876296709-27xu213.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-563037672589001896-qNQId36.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-9234118281519383647-rqmhE0s.png)
这里通过 reexec 机制，执行 docker-untar，并将 dest(刚刚传入的 resolvedPath) 作为参数。其对应的 handler 函数为 untar()：
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-16626771195651321469-XDTNWtx.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-9780811610076866401-e1GmKRT.png)
这里的 flag.Arg(0) 就是阶段一中所获得的 resolvedPath，将其传入 chroot()，来改变当前进程的 root 目录和 cwd 目录，以便进行之后的解包操作。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-17414116944321740870-XpOE1Ie.png)
**但是注意，这里的 path 是 attacker 可控的，有机会设置成指向 host 上任何目录的符号链接**。**由于 chroot 系统调用会对传入的路径中的符号链接进行解析，并且解析时的 scope 目录为宿主机根目录。所以此时 path 中的 component 可以为指向宿主机目录的符号链接，导致 chroot 目标为宿主机上任意目录，并将压缩包解压至该目录中，造成宿主机上任意文件写入。**

### 利用过程

这里的**攻击场景**是：

- 一个非 root 用户/受限用户（执行的命令受限，eg：只能执行 docker cp）可以执行 docker cp 命令。
- 攻击者可以在容器中执行命令/可以定制容器镜像中的 entrypoint。

1. 创建一个容器，在容器中准备 1 个正常目录 normal-dir/ 和 1 个指向 "/" 的符号链接 link-dir/（目标目录可以更换成任意想读取/写入的宿主机文件路径）
2. 使用 renameat2 系统调用不断交换上面准备的两个文件

#### 容器 => 宿主机

3. 在宿主机上执行 docker cp <container-id>:/.../normal-dir/<host_file_name>  <output_path>
4. 重复上一步，直到触发 TOCTOU，**触发的条件**是：在容器中源文件路径解析阶段调用`GetResourcePath()` 时，normal-dir/ 代表一个正常目录；而在打开源文件的阶段调用 `system.OpenSequential()` 时，normal-dir/ 代表一个符号链接文件
5. 利用成功，符号链接指向目录下的 <host_file_name> 文件被复制到 <output_path> 位置，造成任意文件读取（普通用户借用了 dockerd 的高权限）

_实际利用中，发现如果最后一个目录项是符号链接的话，在 archivePath()=>TarWithOptions() 中会因为 srcPath(符号链接) 的 IsDir() 为 false，导致 IncludeFiles 被替换，无法进入到 system.OpenSequential() 的分支中。并且在之后的 filepath.Walk() 中是不会跟踪符号链接的。这样导致利用时，将普通目录切换到符号链接的时机需要限制在 IsDir() 检查之后，filePath.Walk() 之前。_
_可以将切换目标调整到最后一个目录之前的其他目录来解决上述问题。_

#### 宿主机 => 容器

3. 在宿主机上执行 docker cp <src_path> <container-id>:/.../normal-dir/<host_file_name>
4. 重复上一步，直到触发 TOCTOU，**触发的条件**是：在容器中目的文件路径解析阶段调用 `GetResourcePath()`及 `isDir()` 时，normal-dir/ 代表一个正常目录；而在解包到目的路径阶段调用 `chroot()` 时，normal-dir/ 代表一个符号链接文件
5. 利用成功，符号链接指向目录下的 <host_file_name> 文件被写入，写入内容为 <src_path> 的内容，造成任意文件写入（普通用户借用了 dockerd 的高权限）

## poc

[CVE-2018-15664 poc](https://github.com/Metarget/cloud-native-security-book/tree/main/code/0302-%E5%BC%80%E5%8F%91%E4%BE%A7%E6%94%BB%E5%87%BB/02-CVE-2018-15664/symlink_race)

## 修复方案

**临时性修复方案：**
[https://github.com/moby/moby/pull/39252](https://github.com/moby/moby/pull/39252)
在 `containerStatPath()`、`containerArchivePath()` 等存在目录检查/使用时间差的函数中使用 docker pause 和 docker unpause 来冻结和解冻容器，避免在其时间差中的替换目录行为。
**补丁：**
[https://github.com/moby/moby/pull/39292](https://github.com/moby/moby/pull/39292)
在容器中打包/解包操作的过程中，chroot 到容器的 BaseFS(attacker 不可控) 中，限制 attacker 使用符号链接所能到达的范围。
容器内的打包也使用 chrootarchive 包。

## 思考

- 核心问题是**路径中存在符号链接**，在解析时后的上下文在宿主机上的话就会有问题
- 符号链接可以绕过，容器目录拼接，目录字符串检查...
- 审计的时候可以注意一下：
1. 容器可控的符号链接，解析的时机是不是宿主机上下文 
2. 宿主机上下文中解析的符号链接，是否容器可控(CVE-2022-23648)
- 可以通过定制恶意镜像来实现漏洞的利用
将开发部署中常用的目录作为目标，在容器中用 entrypoint 开一个替换目录进程，等待受害者执行 docker cp，完成攻击。
- 审计思路
这里的问题出现在不可信的数据(attacker 可控的 path) 流入了敏感函数(open()/chroot())，做审计时，可以用这个规则粗略分析一下可能出现的风险点，看一下有没有做好限制。这个限制是否做好的标准还需要考虑(比如符号链接的情况)，过滤之后是否立即使用也会影响过滤效果（即使用 evalSymlink 净化之后，如果不立即使用，那么仍然是可控状态，target 变化成符号链接)，如果要做自动化的话。
- TOCTOU 类问题
这类问题感觉会存在很多，怎么样批量找出这些问题呢？这个例子给的经验是，符号链接(尤其是路径符号链接)会导致目录解析一直是可控的，导致 TOCTOU 时间差中可以对路径做操作。

## 相关知识

- _go 中的 io.ReadCloser 知识_

go 的基本 io 接口，ReadCloser 就是定义了 Read() （从数据流中读取字节流）和 Close() （关闭数据流）方法的接口，

- _检查接口是否实现的方法_

变量名.(接口)，eg: `rc, ok := var1.(io.ReadCloser)`

- _docker 的 reexec 机制_

docker 通过 os/exec 包实现的的一种类似 fork 的机制。由于 go 屏蔽了进程、线程的概念，只提供了 goroutine 概念，导致无法像 c 一样使用 fork()。
同时，通过 reexec，docker 还可以提供一种动态注册子命令的方法，并且这些子命令是不向用户公开的(因为会通过 os.arg[0] 来判断子命令)。
首先，在 reexec 包里定义了一个全局变量，用来保存所有子命令；用 `Register()` 向其中注册子命令；在 `Init()` 中检查否有与 `os.Args[0]` 对应的子命令，如果有则调用注册进来的 handler 函数。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-15260055358437175063-JWf1gQN.png)
像上面提到的 `docker-untar` 子命令就是通过 Register 方法注册进来的：
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-2431708599458422890-NZmeXmF.png)
在 docker 的 main 函数开头，会通过调用 reexec.Init() 来检查是否为子命令执行。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-10299532398297488887-yFdMp92.png)
docker 在使用这些子命令时，通过 `reexec.Command()` 方法构造子命令 cmd（其 Path 指向的内容就是 docker 本身），将子命令内容及其参数通过 os/exec 包中的 `Cmd.Args` 传递。构造完毕后，通过 cmd.Start() 开始执行。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-5048981215280088067-yGYgpJU.png)



